//------------------------------------------------
//--- 010 Editor v10.0 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

LittleEndian();

struct
{
    char magic[4];
    int  version;
    int  object_count;
} head <open=true>;

struct obj
{
    enum <uint32> 
    {
        Prop    = 0, /* Scene Prop */
        Entry   = 1, /* Entry Point */
        Item    = 2, /* Item Kind */
        Plant   = 4, /* Flora */
        Passage = 5
    } type;

    uint32 id;
    uint32 unk  <format=hex>;
    float c[9];
    struct 
    {
        float x,y,z;    
    } pos;
    int str_size;
    char str[str_size];
    uint32 entry_no;
    uint32 menu_item_no;
    float scale[3];
} objects[head.object_count] <optimize=false,read=sceneprop__Read>;

uint32 tag;
uint32 id;
float ss[id*3];


uint32 ido;
uint32 tt[ido * 5];            

uint32 ide;
uint32 yy[ide * 5];     

uint32 idu;



string UIntToStr(unsigned int e)
{
    string s; SPrintf(s, "%d", e); return s;
}

string sceneprop__Read(struct obj &m)
{
         if (m.type == Prop ||
             m.type == Item ||
             m.type == Plant)   return EnumToString(m.type) + " -- " + m.str;
    else if (m.type == Entry)   return EnumToString(m.type) + " point number "  + UIntToStr(m.entry_no);
    else if (m.type == Passage) return EnumToString(m.type) + " for menu item " + UIntToStr(m.menu_item_no);
    else                        return EnumToString(m.type);
};