<!DOCTYPE html>
<!-- MADE BY SWYTER ON THE THIRD QUARTER OF 2022
  -- MAKES USE OF A HTML5 COMPLIANT BROWSER, NO EXTERNALS -- HAVE FUN
  -- References: <http://mbmodwiki.ollclan.eu/SceneObj>
  -- Programs used: Notepad++ 5.9.8 with NppFTP, Chromium Dev Tools.
  -->
<html lang="en-EN"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="UTF-8">
	<title>Swyter's Mount&amp;Blade Face code Generator | Just great.</title>
	<link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAG1BMVEUAAAAmJiZNTVRhXV9rZFt4ZmZ2dG2NcXqIioGHzHJjAAAAAXRSTlMAQObYZgAAAG5JREFUeNo1jdEJgDAMRNMNeqULeN1AEb8jRdzABUT8LriBg5so5ifHPV4iggBkRPF1AxBoXRSEhHxWZYPkfGpib6geyjJZs+4zizVhqYmlRYERDpuhO5GjW+aU7Q1Oml/mMF2dWSaR/uub+Ad5AL4eE+r2NulVAAAAAElFTkSuQmCC">
	<style type="text/css">
	html{
		background-color:#998;
		user-select:none;
		-webkit-user-select:none;
		-m//oz-user-select:none; /* if we use this one firefox makes buggy all our input boxes, meh */
		-o-user-select:none;
	}
	body{
		width: 777px;
		white-space: pre-line;
		margin: 0 auto;
		padding:45px;
		/*box-shadow:0 0 6px gray;*/
		box-shadow: 0 0 140px #776;
		
		background-color:#554;
		color:#eee;
		font-size:95%;
		font-family:serif;
		letter-spacing: 2px;
		
		border: 4px double #997;
		border-color:rgba(153, 153, 119, 0.73);
		border-top: 0;

		/* Colorzilla gradient */
		background: #777766;
		background: -moz-linear-gradient(-45deg, #777766 5%, #6d675e 100%);
		background: -webkit-gradient(linear, left top, right bottom, color-stop(5%,#777766), color-stop(100%,#6d675e));
		background: -webkit-linear-gradient(-45deg, #777766 5%,#6d675e 100%);
		background: -o-linear-gradient(-45deg, #777766 5%,#6d675e 100%);
		background: -ms-linear-gradient(-45deg, #777766 5%,#6d675e 100%);
		background: linear-gradient(-45deg, #777766 5%,#6d675e 100%);
		filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#777766', endColorstr='#6d675e',GradientType=1 );
	}
	
	label{
		/*width:95px;
		display: inline-block;
		text-align:right;
		text-shadow:1px 1px black;*/
		
		width: 114px;
		display: inline-block;
		text-align: right;
		text-shadow: 1px 1px black;
		margin-left: 88px;
		-moz-user-select:none; /* firefux clumsy behavior fix */
	}
	
	input,select{
		width:230px;
		-webkit-user-select:unset;
		-m//oz-user-select:unset;
		-o-user-select:unset;
		
		font-family:times,serif;
		text-transform: lowercase;
	}
	
	input#thash{
		width:100%;
		text-align:center;
		font-size:140%;
		font-family:times,serif;
		font-style: oblique;
		text-transform: lowercase;
		box-shadow: 0 0 114px #89A;
	}
	
	input[type=checkbox]{
		width:0/*initial*/;
		padding-right:60px;
		color:gold;
		
		/*width: 46px;
		padding-right: 18px;
		color: gold;
		font-family: serif;
		letter-spacing: 1px;
		text-align: right;
		display: inline-block;
		text-shadow: 1px 1px 0 black;*/	
		
		padding-right: 28px;
		color: goldenrod;
		font-family: serif;
		letter-spacing: 1px;
		text-align: right;
		display: inline-block !important;
		text-shadow: 1px 1px 0 black;
		
		}input[type=checkbox]:after{
		content:'disabled';
		
		}input[type=checkbox]:checked:after{
		content:'enabled' !important;
		color: gold;
	}
	
	h1,h2,h3{
		font-weight: 100;
		text-shadow: 2px 1px black;
		margin:0;
		cursor:default;
		-moz-user-select:none; /* firefux clumsy behavior fix */
	}
	h3{margin-bottom: -29px;}
	h1{
		font-size: 3.6em;
		-webkit-mask: -webkit-linear-gradient(white,rgba(0,0,0,.5) 70%);
		-moz-mask: -moz-linear-gradient(white,rgba(0,0,0,.5) 70%);
	}
	h2{
		border-top: 1px solid #775;
		border-color:rgba(153, 153, 119, 0.42);
		margin-top: -32px;
		letter-spacing: .4em;
		padding-top: 9px;
		
		}h2>span{
		position:absolute;
		/*color:#BE4343;*/
		color:#DB6565;
		-webkit-transform: rotate(9deg); 
		   -moz-transform: rotate(9deg);
		font-size: 15px;
		letter-spacing: 0/*initial*/;
		text-shadow: 0 0 14px red;
		margin-left: -194px;
		margin-top: -58px;
		font-weight: 700;
		opacity: .9;
		text-transform: uppercase;
		
		-webkit-animation-name: pulse; 
		-webkit-animation-duration: 0.5s; 
		-webkit-animation-iteration-count: 100; 
		white-space: nowrap;
		-moz-user-select:none; /* firefux clumsy behavior fix */
	}
	
	img[src*="w3"]{
		width:140px;
	}
	
	@-webkit-keyframes pulse {
	  from {
		opacity: 1;
	  }
	  50% {
		opacity: .75;
	  }
	  to { 
		opacity: 1;
	  }
	}
	
	#pol>option:after{
		content:' meters';
	}
	
	select,option{
		font-family: serif;
		letter-spacing: 1px;
	}
	
	input#thash{
		border: double 4px #89A;
	}
	
	input[type=range]:after{
	 content:"{"attr(value)"}";
		color: #eee;
		display:inline;
		text-align:center;
		font-family:times,serif;
		font-style: oblique;
		text-transform: lowercase;
		text-shadow: 1px 1px black;
		position: relative;
    	left: 30px;
	}

    div#droparea {

        width: 400px; height: 500px; display: inline-block; position: absolute; bottom: 0, left: 0; background: red; border: 1px solid black;
    }

	</style>
</head>
<body>
	<h3>— the one and only —</h3>
	<h1>face code generator</h1>
	<h2>who needs the game, anyway?<span>Ten year anniversary!</span></h2>
	<input id="thash" type="text" placeholder="~Paste your hash here~" data-kpxc-id="thash" value="0x00000001324a9cba0005194a000041ef00005ae800003c55">
	
	<label for="ski">skin         </label>  <input type="number" id="ski" min="0" max="63" value="0">
	<label for="bea">beard        </label>  <input type="number" id="bea" min="0" max="63" value="0">
	<label for="hai">hair         </label>  <input type="number" id="hai" min="0" max="63" value="0"> 
	
	<label for="age">age          </label>  <input id="age" type="range" min="0" max="63" value="18">
	<label for="col">hair color   </label>  <input id="col" type="range" min="0" max="63" value="42">

	<!--input type="range" min="0" max="50" value="25" step="5" /-->
	<label for="fk42">face key 42 </label>  <input id="fk42" type="range" min="0" max="1" value="0"> <!-- count: 21 - cleared skin3 leftmost, only has one bit, i think -->

	<label for="fk41">face key 41 </label>  <input id="fk41" type="range" min="0" max="7" value="0">
	<label for="fk40">face key 40 </label>  <input id="fk40" type="range" min="0" max="7" value="0">
	<label for="fk39">face key 39 </label>  <input id="fk39" type="range" min="0" max="7" value="0">
	<label for="fk38">face key 38 </label>  <input id="fk38" type="range" min="0" max="7" value="0">
	<label for="fk37">face key 37 </label>  <input id="fk37" type="range" min="0" max="7" value="0">
	<label for="fk36">face key 36 </label>  <input id="fk36" type="range" min="0" max="7" value="0">
	<label for="fk35">face key 35 </label>  <input id="fk35" type="range" min="0" max="7" value="0">
	<label for="fk34">face key 34 </label>  <input id="fk34" type="range" min="0" max="7" value="0">
	<label for="fk33">face key 33 </label>  <input id="fk33" type="range" min="0" max="7" value="0">
	<label for="fk32">face key 32 </label>  <input id="fk32" type="range" min="0" max="7" value="0">
	<label for="fk31">face key 31 </label>  <input id="fk31" type="range" min="0" max="7" value="0">
	<label for="fk30">face key 30 </label>  <input id="fk30" type="range" min="0" max="7" value="0">
	<label for="fk29">face key 29 </label>  <input id="fk29" type="range" min="0" max="7" value="0">
	<label for="fk28">face key 28 </label>  <input id="fk28" type="range" min="0" max="7" value="0">
	<label for="fk27">face key 27 </label>  <input id="fk27" type="range" min="0" max="7" value="0">
	<label for="fk26">face key 26 </label>  <input id="fk26" type="range" min="0" max="7" value="0">
	<label for="fk25">face key 25 </label>  <input id="fk25" type="range" min="0" max="7" value="0">
	<label for="fk24">face key 24 </label>  <input id="fk24" type="range" min="0" max="7" value="0">
	<label for="fk23">face key 23 </label>  <input id="fk23" type="range" min="0" max="7" value="0">
	<label for="fk22">face key 22 </label>  <input id="fk22" type="range" min="0" max="7" value="0">
	<label for="fk21">face key 21 </label>  <input id="fk21" type="range" min="0" max="7" value="0"> <!-- count: 22 - skin_3 begins -->

	<label for="fk20">face key 20 </label>  <input id="fk20" type="range" min="0" max="7" value="0"> <!-- count: 21 - cleared skin2 leftmost -->
	<label for="fk19">face key 19 </label>  <input id="fk19" type="range" min="0" max="7" value="0">
	<label for="fk18">face key 18 </label>  <input id="fk18" type="range" min="0" max="7" value="0">
	<label for="fk17">face key 17 </label>  <input id="fk17" type="range" min="0" max="7" value="0">
	<label for="fk16">face key 16 </label>  <input id="fk16" type="range" min="0" max="7" value="0">
	<label for="fk15">face key 15 </label>  <input id="fk15" type="range" min="0" max="7" value="0">
	<label for="fk14">face key 14 </label>  <input id="fk14" type="range" min="0" max="7" value="0">
	<label for="fk13">face key 13 </label>  <input id="fk13" type="range" min="0" max="7" value="0">
	<label for="fk12">face key 12 </label>  <input id="fk12" type="range" min="0" max="7" value="0">
	<label for="fk11">face key 11 </label>  <input id="fk11" type="range" min="0" max="7" value="0">
	<label for="fk10">face key 10 </label>  <input id="fk10" type="range" min="0" max="7" value="0">
	<label for="fk09">face key 09 </label>  <input id="fk09" type="range" min="0" max="7" value="0">
	<label for="fk08">face key 08 </label>  <input id="fk08" type="range" min="0" max="7" value="0">
	<label for="fk07">face key 07 </label>  <input id="fk07" type="range" min="0" max="7" value="0">
	<label for="fk06">face key 06 </label>  <input id="fk06" type="range" min="0" max="7" value="0">
	<label for="fk05">face key 05 </label>  <input id="fk05" type="range" min="0" max="7" value="0">
	<label for="fk04">face key 04 </label>  <input id="fk04" type="range" min="0" max="7" value="0">
	<label for="fk03">face key 03 </label>  <input id="fk03" type="range" min="0" max="7" value="0">
	<label for="fk02">face key 02 </label>  <input id="fk02" type="range" min="0" max="7" value="0">
	<label for="fk01">face key 01 </label>  <input id="fk01" type="range" min="0" max="7" value="0">
	<label for="fk00">face key 00 </label>  <input id="fk00" type="range" min="0" max="7" value="0"> <!-- count: 1 - skin2 begins -->
	<div id=droparea>Drag drop</div>
	<script type="text/javascript">
	/* basic helpers */
	app = document;
	function _(e){return console.log(e);}
	function $(e){return app.getElementById(e);} //who needs jquery anyways? :P
	
	//! http://stackoverflow.com/a/202627
	String.prototype.repeat=function( num ){ return new Array( num + 1 ).join( this );}
	
	//! http://www.2ality.com/2012/02/js-integers.html
	String.prototype.frombin = function ( ) { return parseInt(this,  2);};
	String.prototype.fromdec = function ( ) { return parseInt(this, 10);};
	String.prototype.fromhex = function ( ) { return parseInt(this, 16);};
    Number.prototype.tobin   = function ( ) { var sign = (this < 0 ? "-" : "");var result = Math.abs(this).toString(2);while(result.length < 32) {result = "0" + result;}return sign + result;}
    Number.prototype.tohex   = function ( ) { return this.toString(16);};
	String.prototype.pad     = function (n) { var result=this;while(result.length < n) {result = "0" + result;} return result;}
	
	/* get elements */
	thash=$('thash');
	
	ski=$('ski');
	bea=$('bea');
	hai=$('hai');

	age=$('age');
	col=$('col');
	
	fk42=$('fk42');
	fk41=$('fk41');	fk20=$('fk20');
	fk40=$('fk40');	fk19=$('fk19');
	fk39=$('fk39');	fk18=$('fk18');
	fk38=$('fk38');	fk17=$('fk17');
	fk37=$('fk37');	fk16=$('fk16');
	fk36=$('fk36');	fk15=$('fk15');
	fk35=$('fk35');	fk14=$('fk14');
	fk34=$('fk34');	fk13=$('fk13');
	fk33=$('fk33');	fk12=$('fk12');
	fk32=$('fk32');	fk11=$('fk11');
	fk31=$('fk31');	fk10=$('fk10');
	fk30=$('fk30');	fk09=$('fk09');
	fk29=$('fk29');	fk08=$('fk08');
	fk28=$('fk28');	fk07=$('fk07');
	fk27=$('fk27');	fk06=$('fk06');
	fk26=$('fk26');	fk05=$('fk05');
	fk25=$('fk25');	fk04=$('fk04');
	fk24=$('fk24');	fk03=$('fk03');
	fk23=$('fk23');	fk02=$('fk02');
	fk22=$('fk22');	fk01=$('fk01');
	fk21=$('fk21');	fk00=$('fk00');
	
	/* basic functions */
	
	var hash   = {}
	var struct = {
    //value       //key no. //shift //num bits     //input        //WORKING FINE?
	hair          : [0,      0,      6,            hai        ], // max bits known, adjacent to next left field (beard)
	beard         : [0,      6,      6,            bea        ], // max bits known, adjacent to next left field (skin)
	skin          : [0,     12,      6,            ski        ], // ¡! check max bits for correctness
	hair_color    : [0,     24,      6,            col        ], // max bits known, adjacent to next left field (age)
	age           : [0,     30,      6,            age        ], // ¡! check max bits for correctness

	facekey00     : [1,   3* 0,      3,           fk00        ], //yay -
	facekey01     : [1,   3* 1,      3,           fk01        ], //yay -
	facekey02     : [1,   3* 2,      3,           fk02        ], //yay -
	facekey03     : [1,   3* 3,      3,           fk03        ], //yay -
	facekey04     : [1,   3* 4,      3,           fk04        ], //yay -
	facekey05     : [1,   3* 5,      3,           fk05        ], //yay -
	facekey06     : [1,   3* 6,      3,           fk06        ], //yay -
	facekey07     : [1,   3* 7,      3,           fk07        ], //yay -
	facekey08     : [1,   3* 8,      3,           fk08        ], //yay -
	facekey09     : [1,   3* 9,      3,           fk09        ], //yay -
	facekey10     : [1,   3*10,      3,           fk10        ], //yay -
	facekey11     : [1,   3*11,      3,           fk11        ], //yay -
	facekey12     : [1,   3*12,      3,           fk12        ], //yay -
	facekey13     : [1,   3*13,      3,           fk13        ], //yay -
	facekey14     : [1,   3*14,      3,           fk14        ], //yay -
	facekey15     : [1,   3*15,      3,           fk15        ], //yay -
	facekey16     : [1,   3*16,      3,           fk16        ], //yay -
	facekey17     : [1,   3*17,      3,           fk17        ], //yay -
	facekey18     : [1,   3*18,      3,           fk18        ], //yay -
	facekey19     : [1,   3*19,      3,           fk19        ], //yay -
	facekey20     : [1,   3*20,      3,           fk20        ], //yay -

	facekey21     : [2,   3* 0,      3,           fk21        ], //yay -
	facekey22     : [2,   3* 1,      3,           fk22        ], //yay -
	facekey23     : [2,   3* 2,      3,           fk23        ], //yay -
	facekey24     : [2,   3* 3,      3,           fk24        ], //yay -
	facekey25     : [2,   3* 4,      3,           fk25        ], //yay -
	facekey26     : [2,   3* 5,      3,           fk26        ], //yay -
	facekey27     : [2,   3* 6,      3,           fk27        ], //yay -
	facekey28     : [2,   3* 7,      3,           fk28        ], //yay -
	facekey29     : [2,   3* 8,      3,           fk29        ], //yay -
	facekey30     : [2,   3* 9,      3,           fk30        ], //yay -
	facekey31     : [2,   3*10,      3,           fk31        ], //yay -
	facekey32     : [2,   3*11,      3,           fk32        ], //yay -
	facekey33     : [2,   3*12,      3,           fk33        ], //yay -
	facekey34     : [2,   3*13,      3,           fk34        ], //yay -
	facekey35     : [2,   3*14,      3,           fk35        ], //yay -
	facekey36     : [2,   3*15,      3,           fk36        ], //yay -
	facekey37     : [2,   3*16,      3,           fk37        ], //yay -
	facekey38     : [2,   3*17,      3,           fk38        ], //yay -
	facekey39     : [2,   3*18,      3,           fk39        ], //yay -
	facekey40     : [2,   3*19,      3,           fk40        ], //yay -
	facekey41     : [2,   3*20,      3,           fk41        ], //yay -
	facekey42     : [2,   3*21,      1, /*<- ! */ fk42        ], /* swy: only one bit left, wonky slider in-game; why not exploit the remaining range better? Don't ask me */
}

/*

 face_key_1 = 180000041
 face_key_2 = 36db79b6db6db6fb
                                                 

                                  <------- start-|
                  <------- start-|               |
  <------- start-|               |               |
0x000000018000004136db79b6db6db6fb7fffff6d77bf36db0000000000000000
  _______180000041
       (0)        36db79b6db6db6fb
                        (1)       7fffff6d77bf36db
                                        (2)       ----------------
                                                         (3)
                                                       (unused)

  Here is block (0) from the example above, we will use the bit shift and number of bits columns
  from the table below to build bitmasks and retrieve each field, using the Python 3 prompt:

  For example, age is in block (0), has 6 bits and a shift of 30 bits,
  using hex((pow(2, num_bits) - 1) << bit_shift) we get:

    >>> hex((pow(2,6)-1) << 30)
    '0xfc0000000'
    >>> hex((pow(2,6)-1))
    '0x3f'

    >>> bin((pow(2,6)-1) << 30) # swy: same thing, but in binary
    '0b111111000000000000000000000000000000'
    >>> bin((pow(2,6)-1)) # swy: what this does is just to generate six ones, six bits
    '0b111111'

  Now that we have the right bitmask we can use the logical AND operation to isolate only the bits
  we are interested in and shift them back to the right (we can also see it as removing the padding)
  to get the actual number with just a simple ((block & bitmask) >> bit_shift):

    >>> hex(0x180000041 & 0xfc0000000) # swy: only leave our six potential bits toggled
    '0x180000000'
    >>> bin(0x180000041 & 0xfc0000000) # swy: same thing, but in binary
    '0b110000000000000000000000000000000'
    >>> bin(0x180000041)               # swy: here's the original, compare against the one above
    '0b110000000000000000000000001000001'

    >>> hex((0x180000041 & 0xfc0000000) >> 30) # swy: we are interested in the left-most «110» bit part you see above
    '0x6'
    >>> bin((0x180000041 & 0xfc0000000) >> 30) # swy: so move the bits 30 positions to the right, same but shown in binary
    '0b110'

    >>> ((0x180000041 & 0xfc0000000) >> 30)
    6

||    Do:  0000000000000000000000000000000110000000000000000000000001000001
 |  Mask:  ----------------------------XXXXXX
 | Final:                              000110

  In our case the age field contains the number six. See more examples below.

  _______180000041
                3f # hair: to get the field ((0x180000041 & 0x3f) >> 0), which results in 1
               fc0 # beard
             3f000 # skin
          3f000000 # hair_color: to get the field ((0x180000041 & 0x3f000000) >> 24), which results in 0
         fc0000000 # age: python code to generate a bitmask: hex((pow(2,6)-1) << 30)
*/

	/* handlers */
	app.onchange = function(e)
	{
		switch (e.target)
		{
			case thash: 
				_('a new hash has arrived!');
				_parse(thash.value);
				break;
				
			default:
				_(e.target.id+" has changed");
		}

		for (var key in struct)
		{
			/* swy: not this element? skip it */
			if (e.target != struct[key][3])
				continue;

			/* --- */

			if (e.target.type == "checkbox")
				_out = e.target.checked ? 1 : 0;
			else
				_out = e.target.value;

			_("I've found a new value to change: "+_out);
			
			key_no   = struct[key][0];
			shift    = struct[key][1];
			num_bits = struct[key][2];
			
			
			_outbin = String(_out).fromdec().tobin();
			//_outbin = String('00000000000000000000000000000000'+_outbin
			//	).slice(-num_bits);

			_bin  = hash[ key_no ].substr(0, 8).fromhex().tobin() /* swy: "0000000fc0001000".substr(0, 8):          c0001000 */
			_bin += hash[ key_no ].substr(8, 8).fromhex().tobin() /*      "0000000fc0001000".substr(8, 8):  0000000f         */


			//_bin = String('00000000000000000000000000000000'+_bin
			//	).slice(_bin.length);
			
			_cut = _bin.substr( -(shift+num_bits), num_bits );
			
			base= _bin.length;
			basb= _cut.length;
			
			_("//key no. //shift //num bits");
			_("|| Struct: " + struct[key]);
			_("     base: " + base);
			_("    shift: " + shift);
			_('||    Do:  ' + ('-').repeat( (64-base) ) + _bin );


			_(' |  Mask:  ' + ('-').repeat( 64-(num_bits)-(shift) ) + ('X').repeat( (num_bits) ) );
			_(' | Final:  ' + (' ').repeat( 64-(num_bits)-(shift) ) + _outbin.substr(-num_bits) );
			_(' |  Prev:  ' + (' ').repeat( 64-(num_bits)-(shift) ) + _cut );
			
			//Reset the enabled bitmask values by XOR'ing them with themselves...
			/*-->
			
			_reset= ( _bin.frombin() ) ^ ( _cut.frombin() << shift );
			_(' | Reset:  '  + _reset.tobin() );

			//Add the new values by OR'ing them with the noew blank shift range/scope...
			_added= ( _reset | _out << shift);
			_(' | Added:  '  + _added.tobin() );
			
			<--*/
			
			//There's a limitation in bitwise operations in js: 32 bit signed integers, so if we set the last bit it turns out negative :/
			//_outhack = (_out << shift).tobin().substr( -(shift+num_bits), num_bits );
			
			_("----------");
			_("    out:" + _out);
			_outhack = Number(_out).tobin().substr( -(num_bits), num_bits );
			_("outhack:" + _outhack);
			_("togther:" + _bin.substr(0, 64-(num_bits+shift))+"|"+_outhack.substr(-num_bits)+"|"+_bin.substr(-shift,shift))
			_("----------");
			
			hash_bin = (
					/* 1st orig. chunk */		_bin.substr(0, 64-(num_bits+shift) ) +
					/* our modif. part */	_outhack.substr(-num_bits) +
					/* 2nd orig. chunk */	    _bin.substr(-shift,shift)
							
							);
			hash[key_no]  = hash_bin.substr( 0, 32).frombin().tohex().pad(8);
			hash[key_no] += hash_bin.substr(32, 32).frombin().tohex().pad(8);
							
			if (e.target.attributes[4]) {
				e.target.attributes[4].value=_out; //manages the display of the values in sliders
			}
			
			thash.value='0x'+(hash[0] + hash[1] + hash[2] + hash[3]);
			//_parse(thash.value);
			break;
		}
	}
	
//	app.onkeydown=function(e)
//	{
//		/* swy: only react to the Enter key */
//		if (e.keyIdentifier == 'Enter' || e.keyCode == 13) //firefux doesn't supprts keyIdentifier, of course :(
//		{
//			//if (e.target!=flseed && e.target!=riseed && e.target!=teseed){return 0;}
//			_("boom");
//			//! http://stackoverflow.com/a/6005163
//			e.target.value = Math.floor(Math.random() * ( 65535 /* even better, 4 ones, as the game does 1048575/* use half of the bitmask instead 2147483647*/ + 1));
//			app.onchange(e); // we've to force a new state so the app knows that the randomization has been launched by the user :)
//		}
//	}
	
	function _parse(e)
	{
		e=e.replace('0x','');
		if (e.length != 64)
		{
			_("badly formatted hash :(");
			return false; //doesn't validate
		}
		
		for (var i=1; i<=4; i++) // 4 64-bit chunks == 8 32-bit chunks
			hash[3-(i-1)] = /*parseInt(*/e.substr(-16*i,16)/*, 16).toString(2)*/;

		//https://ricochen.wordpress.com/2010/04/24/javascript-zero-padding-numbers/
		//String('00000'+n).slice(-5);
		_(e);
		_(hash[0] + hash[1] + hash[2] + hash[3]);
		
		
		for (var key in struct)
		{
			_("---");
			_("||    Key: " + key);
			_("//key no. //shift //num bits");
			_("|| Struct: " + struct[key]);
 		 
			key_no   = struct[key][0];
			shift    = struct[key][1];
			num_bits = struct[key][2];

			/* swy: split them in two because the fromhex() and tobin() functions can't
			        really handle more than 32 bits at a time */
			_bin  = hash[ key_no ].substr(0, 8).fromhex().tobin() /* swy: "0000000fc0001000".substr(0, 8):          c0001000 */
			_bin += hash[ key_no ].substr(8, 8).fromhex().tobin() /*      "0000000fc0001000".substr(8, 8):  0000000f         */
			_bin = _bin.pad(_bin.length);

			_cut = _bin.substr( -(shift+num_bits), num_bits );

			base= _bin.length;
			basb= _cut.length;
			_("     base: " + base);
			_("    shift: " + shift);


			_('||    Do:  '  + ('-').repeat( (64-base) ) + _bin );


			_(' |  Mask:  '  + ('-').repeat( 64-(num_bits)-(shift) ) + ('X').repeat( (num_bits) ) );
			//_('||       '  + ('-').repeat( (64-base) ) + ('.').repeat( (64-base)+(64-basb)-2 ) + _cut );
			_(' | Final:  '  + (' ').repeat( 64-(num_bits)-(shift) ) + _cut );

			_dec = _cut.frombin();
			_('');
			_('|| Decim: ' + _dec);
			_bool= ((_dec==0) ? false : true );
			_('||  Bool: ' + _bool);

			_( struct[key][1]*struct[key][0]+" / size: " + struct[key][2]);

			//update our controls
			struct[key][3].value=_dec;

			if (struct[key][3].attributes[4])
				struct[key][3].attributes[4].value=_dec; //manages the display of the values in sliders

			//if (_bool){
			struct[key][3].checked=_bool;
			//}
		}
	}

	//! dbg----
	window.onload = function()
	{
		if (window.location.hash == '')
		{
			def = '0x000000000000000036db6db6db6db6dbb6db6db6db6db6db0000000000000000';
			thash.value = def;
			_parse(def);
		}
		else
			window.onhashchange();
	}
	
	//! permalink
	window.onhashchange = function()
	{
		def=window.location.hash.replace('#', '');
		thash.value = def;
		_parse(def);
	}

    droparea = document.querySelector("div#droparea")

	droparea.ondrop = function(e)
	{
		console.log(e);
		console.log(e.dataTransfer.files[0])
		e.preventDefault();
	}

	droparea.ondragover = function(e)
	{
		console.log(e);
        e.preventDefault();
	}

	race = [];
    function parse_skins_txt(text_file)
    {
        var state = 'MAGIC';

        var race_count = 0;
        var cur_race_idx = 0;
        var cur_hair_count = 0;
        var cur_beard_count = 0;

		var txt = text_file.split('\n');

		for (var linetxt of txt)
		{
			var line = linetxt.replace(/[\t ]+/g, ' ').replace(/^[ ]*/g, '').replace(/[ ]*$/g, '').split(' ');
			console.log(line);

			switch (state)
			{
				case 'MAGIC':
				{
					if (state == 'MAGIC' && linetxt == 'skins_file version 1')
						state = 'READ_RACE_COUNT';
					else
						console.warn(`swy: bad file magic value: ${linetxt}`);
				}
				break;

				case 'READ_RACE_COUNT':
				{
					race_count = line[0];
					state = 'READ_RACE_NAME';
				}
				break;

				case 'READ_RACE_NAME':
				{
					cur_race_idx = line[1];
					race[cur_race_idx]={};
					race[cur_race_idx]["name"] = line[0];
					state = 'READ_RACE_MESHES';
				}
				break;

				case 'READ_RACE_MESHES':
				{
					race[cur_race_idx]["mesh_body"] = line[0];
					race[cur_race_idx]["mesh_calf"] = line[1];
					race[cur_race_idx]["mesh_hand"] = line[2];
					state = 'READ_RACE_HEAD';
				}
				break;

				case 'READ_RACE_HEAD':
				{
					race[cur_race_idx]["mesh_head"] = line[0];
                    race[cur_race_idx]["face_keys"] = [];

                    var face_key_count = line[1];

					for (i = 0, idx = 2; i < face_key_count; i++, idx += 5)
						race[cur_race_idx]["face_keys"].push({id: line[idx], a: line[idx + 1], b: line[idx + 2], c: line[idx + 3], d: line[idx + 4] }); /* swy: the data starts at line[2] */

					state = 'READ_RACE_HAIR_COUNT';
				}
				break;

				case 'READ_RACE_HAIR_COUNT':
				{
					cur_hair_count = line[0];
					state = 'READ_RACE_HAIR';
				}
				break;

				case 'READ_RACE_HAIR':
				{
					race[cur_race_idx]["mesh_hair"] = [];

					for (i = 0; i < cur_hair_count; i++)
						race[cur_race_idx]["mesh_hair"].push(line[i]);

					state = 'READ_RACE_BEARD_COUNT';
				}
				break;

				case 'READ_RACE_BEARD_COUNT':
				{
					cur_beard_count = line[0];
					state = 'READ_RACE_BEARD';
				}
				break;

				case 'READ_RACE_BEARD':
				{
					if (!race[cur_race_idx]["mesh_beard"])
						race[cur_race_idx]["mesh_beard"] = [];

					race[cur_race_idx]["mesh_beard"].push(line[0]);

					if (--cur_beard_count <= 0)
						state = 'READ_RACE_HAIR_MATERIALS';
				}
				break;

				case 'READ_RACE_HAIR_MATERIALS':
				{
					race[cur_race_idx]["mat_hair"] = [];
					hair_mat_count = line[0];

					/* swy: skip the empty line */
					if (hair_mat_count <= 0)
						continue;

					for (i = 0; i < hair_mat_count; i++)
						race[cur_race_idx]["mat_hair"].push(line[1 + i]);

					state = 'READ_RACE_BEARD_MATERIALS';
				}
				break;

				case 'READ_RACE_BEARD_MATERIALS':
				{
					race[cur_race_idx]["mat_beard"] = [];
					beard_mat_count = line[0];

					for (i = 0, idx = 1; i < beard_mat_count; i++, idx += 1)
						race[cur_race_idx]["mat_beard"].push(line[idx]); /* swy: the data starts at line[1] */

					state = 'READ_RACE_FACE_MATERIALS';
				}
				break;

				case 'READ_RACE_FACE_MATERIALS':
				{
					race[cur_race_idx]["mat_face"] = [];
					face_mat_count = line[0];

					for (i = 0; i < face_mat_count; i++)
						race[cur_race_idx]["mat_face"].push(line[1 + i]);

					state = 'READ_RACE_SOUNDS';
				}
				break;

				case 'READ_RACE_SOUNDS':
				{
					race[cur_race_idx]["sounds"] = [];
					sounds_count = line[0]; const constant_lookup = ['die', 'hit', 'grunt', 'grunt_long', 'yell', 'warcry', 'victory', 'stun'];

					for (i = 0, idx = 1; i < sounds_count; i++, idx +=2)
						race[cur_race_idx]["sounds"].push({type: constant_lookup[line[idx]], name: line[idx + 1]});

					state = 'READ_RACE_SKELETON';
				}
				break;

				case 'READ_RACE_SKELETON':
				{
					race[cur_race_idx]["skeleton"] = { name: line[0], scale: line[1] };
					state = 'READ_RACE_UNK';
				}
				break;

				case 'READ_RACE_UNK':
				{
					state = 'READ_RACE_RESTRICTIONS_COUNT';
				}
				break;

				case 'READ_RACE_RESTRICTIONS_COUNT':
				{
                    cur_restrictions_count = line[0];
					state = 'READ_RACE_RESTRICTIONS';
				}
				break;

				case 'READ_RACE_RESTRICTIONS':
				{
                    if (line[0]<=0)
                        continue;

                    if (--cur_restrictions_count <= 1)
                    {
                        /* swy: we're done for this entry, start parsing the next one, if any */
                        console.log(">> parsed race: ", race[cur_race_idx]);
						state = 'READ_RACE_NAME';
                    }
				}
                break;
			}
			
		}
    }

	xhr = new XMLHttpRequest;
	xhr.open('GET', 'https://gist.githubusercontent.com/Swyter/0b03cdae54886afc5ff2e51f3d8f1223/raw/383bc333829c2867132a9737d2079798c38cd73c/skins.txt');
	xhr.onloadend = function(e)
	{
		if (e.target.readyState != e.target.DONE)
			return;

		if (e.target.status != 200)
			return;

        parse_skins_txt(e.target.response);

        var labels = document.querySelectorAll(`label[for^=fk]`);

        labels[0].textContent = race[0].name;

		console.log(e);
	}
	xhr.send();

	</script>
</body></html>