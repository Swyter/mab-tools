//------------------------------------------------
//--- 010 Editor v10.0 Binary Template
//
//      File: Mount&Blade Binary Resource File
//   Authors: Swyter
//   Version: 2020.07.01
//   Purpose: Opens M&B 1.011 and Warband BRF files (Resource/*.brf)
//  Category: Game
// File Mask: *.brf
//  ID Bytes: 
//------------------------------------------------

LittleEndian();

typedef struct
{
    uint tag_len;
    char s[tag_len];
} rgltag <read=read_rgltag>;

string read_rgltag(struct rgltag& _thing)
{
    return _thing.s;
}

struct texture
{
    uint object_count;

    struct tex_t
    {
        rgltag tex_name <bgcolor=cSilver>;
        uint32 flag <format=hex>;
    } elem[object_count] <optimize=false, read=read_tex>;
};

struct shader
{
    uint object_count;

    struct sha_t
    {
        rgltag tex_name <bgcolor=cSilver>;
        uint32 flag <format=hex>;
        int thing;
        rgltag technique;
        uint alt_count; /* swy: alt shader names, used as fallback, generally zero or one */
        struct { rgltag t; } alt[alt_count];
        uint count;
        struct
        {
            uint map, color_op, alpha_op, flag;
        }entry[count];
    } elem[object_count] <optimize=false, read=read_sha>;
};

struct material
{
    uint object_count;

    struct mat_t
    {
        rgltag mat_name <bgcolor=cSilver>;
        uint32 flag <format=hex>;

        rgltag shader_name <bgcolor=cSilver>;

        rgltag diffuse_a <bgcolor=cSilver>;
        rgltag diffuse_b;
        rgltag bump;
        rgltag environ;
        rgltag specular;
        float coeff;
        float spec_r, spec_g, spec_b;
    } elem[object_count] <optimize=false, read=read_mat>;
};

struct mesh
{
    uint object_count;
    struct mesh_t
    {
        rgltag mesh_name <bgcolor=cRed>;
        uint32 flag <format=hex>;
        rgltag mat_name <bgcolor=cSilver>;
        uint pos_cnt;
        struct 
        {
            float x, y, z;
        } pos[pos_cnt];

        uint bone_count;
        if (bone_count)
        {
            uint twelve, b;
            struct
            {
                uint idx;
                float thing;
            } bone[bone_count*30];
        }

        uint extra_frames;
        if (extra_frames)
        {
            uint time;
            uint pos_cnt_;
            struct 
            {
                float x, y, z;
            } pos_[pos_cnt_];

            uint pos_cnt__;
            struct 
            {
                float x, y, z;
            } pos__[pos_cnt__];
        }
        uint vtx_cnt;
        struct
        {
            int pos_idx;
            union
            {
              uint color <format=hex>;
              struct
              {
                ubyte r,g,b,a;
              } components;
            } rgb;
            float  n_a, n_b, n_c, x_a, x_b, y_a, y_b;
        } vtx[vtx_cnt * (extra_frames + 1)];

        int tri_cnt;

        struct
        {
            int a[3];
        } tri[tri_cnt];
    } elem[object_count] <optimize=false, read=read_mesh>;
};


struct skel_ani
{
    uint object_count;
    struct ska_t
    {
        rgltag mesh_name <bgcolor=cRed>;
        uint32 bone, frames;
        struct
        {
            uint idx;
            float thia[4];
        } a[bone * 4];
        rgltag mat_name <bgcolor=cSilver>;
    } elem[object_count] <optimize=false, read=read_ska>;
};

struct body
{
    uint object_count;
    struct body_t
    {
        rgltag body_name;

        struct body_type
        {
            rgltag body_type <bgcolor=cSilver>;

            if      (Stricmp(body_type.s, "composite") == 0)
            {
                uint composite_cnt; /* swy: recursive thingie; contains a number of other sphere/capsule/manifold items */
                struct body_type composite[composite_cnt] <optimize=false>;
            }
            else if (Stricmp(body_type.s, "sphere") == 0)
            {
                float radius, x,z,y; uint flag <format=hex>;
            }
            else if (Stricmp(body_type.s, "capsule") == 0)
            {
                float radius, x,z,y, x,z,y; uint flag <format=hex>;
            }
            else if (Stricmp(body_type.s, "manifold") == 0)
            {
                uint vtx_elem;
                struct { float xyz[3]; } vtx[vtx_elem];

                uint poly_elem;
                struct { int minus_one, unk_zero, vtx_idx_cnt; uint vtx_idx[vtx_idx_cnt]; } poly[poly_elem] <optimize=false>;
            }
        } body <optimize=false>;
    } elem[object_count] <optimize=false, read=read_body>;
};


/* swy: iterate over all the posible BRF chunks */
while (FTell() < FileSize())
{
    struct brf_section
    {
        rgltag tag <bgcolor=cDkYellow>;
    
             if (Stricmp(tag.s, "texture"      ) == 0) struct texture  tex <open=true, bgcolor=cWhite>;
        else if (Stricmp(tag.s, "shader"       ) == 0) struct shader   sha <open=true, bgcolor=cWhite>;
        else if (Stricmp(tag.s, "material"     ) == 0) struct material mat <open=true, bgcolor=cDkGreen>;
        else if (Stricmp(tag.s, "mesh"         ) == 0) struct mesh     mes <open=true, bgcolor=cDkRed>;
        else if (Stricmp(tag.s, "skeleton_anim") == 0) struct skel_ani ska <open=true, bgcolor=cDkRed>;
        else if (Stricmp(tag.s, "body"         ) == 0) struct body     bod <open=true, bgcolor=cDkBlue>;
        else if (Stricmp(tag.s, "end"          ) == 0);
    } section <optimize=false, open=true, read=read_brf>;
}


string read_tex(struct tex_t& _thing)
{
    return "- " + _thing.tex_name.s;
}
string read_sha(struct sha_t& _thing)
{
    return "- " + _thing.tex_name.s;
}
string read_mat(struct mat_t& _thing)
{
    return "- " + _thing.mat_name.s;
}
string read_mesh(struct mesh_t& _thing)
{
    return "* " + _thing.mesh_name.s;
}
string read_ska(struct ska_t& _thing)
{
    return "* " + _thing.mesh_name.s;
}
wstring read_body(struct body_t& _thing)
{
    return "- " + _thing.body_name.s;
}
string read_brf(struct brf_section& _thing)
{
    return "[" + _thing.tag.s + "]";
}