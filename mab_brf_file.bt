//------------------------------------------------
//--- 010 Editor v10.0 Binary Template
//
//      File: Mount&Blade Binary Resource File
//   Authors: Swyter
//    E-mail: swyterzone+mab@gmail.com
//   Version: 2020.07.01
//   Purpose: Opens M&B 1.011 and Warband BRF files (Resource/*.brf)
//  Category: Game
// File Mask: *.brf
//
//     Notes: The Warband format changes a bit the original mesh chunk structure; adding
//            tangents for better (tangent-space) normal mapping and other stuff.
//
//            To distinguish between older and newer files, TaleWorlds added a
//            'resource file versioning' chunk, that needs to go first.
//
//            Keep in mind that TaleWorlds used .trf files internally, which are
//            just readable text versions of this very same format, they were generated by
//            their own wonky Blender script exporter that no one outside the company ever used,
//            because they released it very late in the Warband lifecycle, next to the Data part of the
//            module system and the HLSL shaders in text form, when the community had way better tools.
//
//            In the end, I think we all (even them and the modders-turned-authors of the DLCs themselves)
//            ended up using community-provided tools like (first) BRF Edit and then OpenBRF to open and
//            edit these binary counterparts. But originally they weren't meant for authoring, only
//            for faster parsing/loading. Weird how that turned out. Thanks, Marco Tarini! :)
//
//            The game actually spits a `thing.brf` when you put a `thing.trf` in CommonRes or Resources
//            and there isn't already a 'cached' BRF in there. Does it check if the file is newer? ¯\_(ツ)_/¯
//------------------------------------------------

LittleEndian();

typedef struct
{
    uint tag_len;
    char s[tag_len];
} rgltag <read=read_rgltag>;

string read_rgltag(struct rgltag& _thing)
{
    return _thing.s;
}

/* -- */

local uint is_wb_brf = false;

/* swy: the rfver chunk is Warband-only, and what we use to distinguish these files
        from their (mostly identical) 1.011 counterparts */
struct rfver
{
    enum <uint32>
    {
        Warband = 1,        /* swy: there's no version *zero*, Warband introduced the rfver tag at 1, */
    } res_file_version_tag; /*      and Bannerlord uses different formats altogether.                 */

    if (res_file_version_tag == Warband)
        is_wb_brf = true;
};

struct texture /* swy: this is actually more like a texture *reference*, as glue between a material and a .DDS file */
{
    uint object_count;
    struct tex_t
    {
        rgltag tex_name <bgcolor=cSilver>; /* swy: path to the Modules/<mod-name>/Textures/<texture-name>.dds file where the data is actually stored,  */
        union                              /*      only a limited subset of DX9 DDS textures are supported: ST3C and a few others, not DirectX 11 ones */
        {
            uint32 val <format=hex>;
            struct
            {
                uint unk : 1;
                uint force_hi_res : 1;
                uint unk : 1;
                uint language_dependent : 1;
                uint hdr_only : 1;
                uint no_hdr : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint unk : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                enum <uint> tex_size_flags
                {
                    TSF_default, TSF_2, TSF_4, TSF_8, TSF_16, TSF_32, TSF_64, TSF_128, TSF_256, TSF_512, TSF_1024, TSF_2048, TSF_4092, TSF_8K, TSF_16K, TSF_32K
                } size_u : 4 <format=hex>;
                enum tex_size_flags size_v : 4 <format=hex>;
                uint clamp_u : 1;
                uint clamp_v : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                enum <uint> tex_anim_flags
                {
                    TAF_0, TAF_4, TAF_8, TAF_12, TAF_16, TAF_20, TAF_24, TAF_28, TAF_32, TAF_36, TAF_40, TAF_44, TAF_48, TAF_52, TAF_56, TAF_60
                } animation_frames : 4;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
            } flags <open=true>;
        } flag <open=true>;
    } elem[object_count] <optimize=false, read=read_tex>; /* swy: when a texture has multiple frames (like waterbump) every frame is stored as its own files, like this: <texture-name>_<frame-number-that-starts-at-zero>.dds */
};

struct shader
{
    uint object_count;
    struct sha_t
    {
        rgltag tex_name <bgcolor=cSilver>;
        union
        {
            uint32 val <format=hex>;
            struct
            {
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint specular_enable : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint static_lighting : 1;

                uint uses_envmap : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint preshaded : 1;
                uint uses_instancing : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint biased : 1;

                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;

                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint uses_pixel_shader : 1;
                uint uses_hlsl : 1;
                uint uses_normal_map : 1;
                uint uses_skinning : 1;
            } flags <open=true>;
        } flag <open=true>;
        uint unk_zero;
        rgltag technique; /* swy: originally the HLSL technique name in mb.fx, later also mapped to GLShaders/techniques.xml for GLSL program binding on the OpenGL backend used for Linux, macOS and Android */
        uint alt_count;   /* swy: alt shader names; used as fallback and originally shipped as *.pp asm files for low-spec computers, generally zero or one */
        rgltag alt[alt_count];
        uint count;
        struct
        {
            int map; uint color_op, alpha_op, flag;
        }entry[count];
    } elem[object_count] <optimize=false, read=read_sha>;
};

struct material
{
    uint object_count;
    struct mat_t
    {
        rgltag mat_name <bgcolor=cSilver>;
        union
        {
            uint32 val <format=hex>;
            struct
            {
                uint no_fog : 1;
                uint no_lighting : 1;
                uint dont_block_light : 1;
                uint no_z_write : 1;
                uint no_depth_test : 1;
                uint specular_enable : 1;
                uint uniform_lighting : 1;
                uint maybe_unused : 1 <hidden=true>;
                enum <uint> mat_transp_flags /* swy: more like material blending modes */
                {
                    MTF_opaque,                                    /* swy: always opaque */
                    MTF_blend_alpha,                               /* Blend              */ /* [ S*a + D*(1-a) ] */
                    MTF_blend_additive_alpha,                      /* Add (lighten)      */ /* [ S*a + D ]       */
                    MTF_blend_multiply_darken,                     /* Multiply (darken)  */ /* [ S * D ]         */
                    MTF_blend_additive_no_alpha,                   /* Add, no alpha      */ /* [ S + D ]         */
                    MTF_undefined,
                    MTF_undefined_b,
                    MTF_default_blend_when_alpha_is_less_than_one, /* Auto  (blend if mat.a<1) */
                } transparency : 3;
                uint auto_normalize_normals : 1;
                enum <uint> mat_alphatest_flags
                {
                    MAF_none,
                    MAF_large_margin,  /* transparent when texture alpha is less than   8/256 => 0.03125f    */
                    MAF_normal_margin, /* transparent when texture alpha is less than 136/256 => 0.53125f    */
                    MAF_tight_margin,  /* transparent when texture alpha is less than 251/256 => 0.98046875f */
                } alpha_test : 2;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint render_first : 1;
                uint origin_at_camera : 1;
                uint combine_meshes : 1;
                uint warband_combine_low_poly_meshes : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                enum <uint> mat_render_order
                {
                    /* 0001 -8 */ MRO_minus_8 = 0b1000,
                    /* 1001 -7 */ MRO_minus_7 = 0b1001,
                    /* 0101 -6 */ MRO_minus_6 = 0b1010,
                    /* 1101 -5 */ MRO_minus_5 = 0b1011,
                    /* 0011 -4 */ MRO_minus_4 = 0b1100,
                    /* 1011 -3 */ MRO_minus_3 = 0b1101,
                    /* 0111 -2 */ MRO_minus_2 = 0b1110,
                    /* 1111 -1 */ MRO_minus_1 = 0b1111,
                    /* 0000  0 */ MRO_zero    = 0b0000,
                    /* 1000 +1 */ MRO_plus_1  = 0b0001,
                    /* 0100 +2 */ MRO_plus_2  = 0b0010,
                    /* 1100 +3 */ MRO_plus_3  = 0b0011,
                    /* 0010 +4 */ MRO_plus_4  = 0b0100,
                    /* 1010 +5 */ MRO_plus_5  = 0b0101,
                    /* 0110 +6 */ MRO_plus_6  = 0b0110,
                    /* 1110 +7 */ MRO_plus_7  = 0b0111,
                } render_order : 4 <format=hex>;
                uint invert_bumpmap : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
            } flags <open=true>;
        } flag;

        rgltag shader_name <bgcolor=cSilver>;

        rgltag diffuse_a <bgcolor=cSilver>;
        rgltag diffuse_b;
        rgltag bump;
        rgltag environ;
        rgltag specular;
        float coeff;
        float spec_r, spec_g, spec_b;
    } elem[object_count] <optimize=false, read=read_mat>;
};

struct mesh
{
    uint object_count;
    struct mesh_t
    {
        rgltag mesh_name <bgcolor=cRed>;
        union
        {
            uint32 val <format=hex>;
            struct
            {
                uint unk_props : 1;
                uint unk_particles : 1;
                uint unk_plants : 1;
                uint unk_particles_b : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint unk_hair_and_body_parts : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint unk_particles : 1;
                uint unk_screen_space : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint reserved_warband_tangent_space : 1;
                uint reserved_warband_model_format  : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint pre_exponentiate_colors : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint unk_particles_c : 1;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
                uint maybe_unused : 1 <hidden=true>;
            } flags <open=true>;
        } flag;
        rgltag mat_name <bgcolor=cSilver>;

        /* swy: unique vertex positions for this mesh, deduplicated from the vtx array, we don't want to store three
                floats there each time; instead of that, a single index pointing here will do */
        uint pos_cnt;

        struct 
        {
            float x, y, z;
        } pos[pos_cnt];

        /* swy: every vertex can be moved by/get attached to a maximum of four bones, and the sum of all its influences must
                be 1.0 (e.g. Vertex index 34: (Bone A) 0.25 + (Bone B) 0.75 = 1.0f, this vertex is mostly going to follow
                bone B while still being nudged a bit by Bone A as each of them move around) */
        uint bone_count;
        struct bone_influence
        {
            uint bone_id, count;
            struct
            {
                uint idx;
                float weight; /* swy: amount of normalized influence this bone has over the vertex */
            } bone[count];
        } bi[bone_count] <optimize=false>;

        /* swy: every mesh has a base "frame" by default, here any additional snapshots of the same displaced mesh are stored
                as variations of existing positions (and their corrected normals, to still get correct lighting)
                this is used for morph targets, from face morphing to moving crowsbows; always limited by the
                existing number and IDs of the base vertex; we can't add new per-frame UVs or colors */
        uint extra_frames;
        struct vertex_frame
        {
            uint time; /* swy: this is what the game actually uses in the frame timeline; sometimes searching for specific/hardcoded numbers */

            uint pos_cnt; /* swy: overriden vertex position (for this frame) */
            struct 
            {
                float x, y, z;
            } pos[pos_cnt];

            uint nrm_cnt; /* swy: overriden vertex normal (for this frame) */
            struct 
            {
                float x, y, z;
            } nrm[nrm_cnt];
        } vtxfrm[extra_frames] <optimize=true>;

        /* swy: actual vertex definitions go here; where the actual properties are stored, keep in mind that because various
                vertices can exist at the same position the {x,y,z} positions are saved separately (in the pos array) and
                indexed in their own array to avoid duplication/redundancies */
        uint vtx_cnt;
        struct
        {
            int pos_idx;
            union
            {
              uint color <format=hex>;
              struct
              {
                ubyte r,g,b,a;
              } components;
            } rgb;

            if (!is_wb_brf) /* swy: FIXME: find out and complete what each of the unknown fields really does internally, probably just computed tangent stuff for nifty-looking normal maps */
            {
                float n_a, n_b, n_c, u, v, u_unused, v_unused;  /* swy: OpenBRF copies the u/v fields into the unused ones, which are blank in original BRF files */
            }
            else
            {
                float n_a, n_b, n_c, unk_a, unk_b, unk_z; byte unk_one_or_zero_tangent_flip_or_not_maybe /* handedness?; false => 1 or true => -1 */; float u, v;
            }
        } vtx[vtx_cnt] <optimize=true>;

        /* swy: a list of triangles; each triangle can index three vertices from the (previous) vtx array */
        int tri_cnt;
        struct
        {
            int a[3];
        } tri[tri_cnt];
    } elem[object_count] <optimize=false, read=read_mesh>;
};

struct skel
{
    uint object_count;
    struct skl_t
    {
        rgltag mesh_name <bgcolor=cRed>;
        uint32 bone_count; /* swy: humans have 20 bones, while mounts have 28 */
        struct
        {
            int parent_idx; /* swy: parent bone, up in the chain we depend on; as transformations are relative to them; -1 for the root bone */
            rgltag bone_name <bgcolor=cSilver>;
            int flag_zero; /* swy: seems unused, I think :) */
            float local_transform_matrix[9]; /* swy: affine transformation 3x3 matrix (i.e. encodes local rotation) */
            float x, z, y; /* swy: bone rest position while T-posing */
        } bon[bone_count] <optimize=false>;
    } elem[object_count] <optimize=false, read=read_skl>;
};

struct skel_ani
{
    uint object_count;
    struct ska_t
    {
        rgltag mesh_name <bgcolor=cRed>;
        uint32 bone_count; /* swy: humans have 20 bones, while mounts have 28 */
        struct /* swy: bind/T pose bones, in local space; every bone has a parent bone, */
        {      /*      except the root, whose parent is (-1). transform relatively and translate. */
            uint32 frames;
            struct
            {
                uint idx;
                float quaternion[4];
            } a[frames];
        } bon[bone_count] <optimize=false>;

        struct
        {
            uint32 frames;
            struct
            {
                uint frame;
                float pos[3]; /* swy: FIXME: this seems like a relative movement for each frame from the root bone, probably added to the agent position/coordinates in-engine */
            } b[frames];
        } root_bone_translation;
    } elem[object_count] <optimize=false, read=read_ska>;
};

struct body
{
    uint object_count;
    struct body_t
    {
        rgltag body_name;
        struct body_type
        {
            rgltag body_type <bgcolor=cSilver>;

                 if (Stricmp(body_type.s, "composite") == 0)
            {
                uint composite_cnt; /* swy: recursive thingie; contains a number of other sphere/capsule/manifold items */
                struct body_type composite[composite_cnt] <optimize=false>;
            }
            else if (Stricmp(body_type.s, "sphere"   ) == 0) /* swy: a 3D point with a radius, anything (another point) closer to the center point than that is colliding */
            {
                float radius, x,z,y; uint flag <format=hex>;
            }
            else if (Stricmp(body_type.s, "capsule"  ) == 0) /* swy: a capsule is a line capped by two spheres at either end, with the line having the same radius as them at any point (it can also be seen as a sphere sliding through a line; so if you find the closest line-point position and then do a sphere check it's the same thing) */
            {
                float radius, x,z,y, x,z,y; uint flag <format=hex>;
            }
            else if (Stricmp(body_type.s, "face"     ) == 0) /* swy: only ever used in bo_mesh_passage, as far as I know */
            {
                uint vtx_count; struct { float x, z, y; } vtx[vtx_count]; uint flag <format=hex>;
            }
            else if (Stricmp(body_type.s, "manifold" ) == 0) /* swy: admits quad and triangle soups (maybe even arbitrary (5-sided+) polygons?) */
            {
                uint vtx_count;
                struct { float x, z, y; } vtx[vtx_count];

                uint poly_elem;
                struct { int minus_one, unk_zero, vtx_count; uint vtx_idx[vtx_count]; } poly[poly_elem] <optimize=false>;
            }
        } body <optimize=false>;
    } elem[object_count] <optimize=false, read=read_body>;
};


/* swy: iterate over all the posible BRF chunks */
while (FTell() < FileSize())
{
    struct brf_section
    {
        rgltag tag <bgcolor=cDkYellow>;
        /* swy: listed in the same order as in the original code that parses/builds these things from .trf (text) files */
             if (Stricmp(tag.s, "rfver "       ) == 0) struct rfver    ver <open=true, bgcolor=cWhite>; /* swy: versioning chunk prefixing pseudo-header introduced in Warband */
        else if (Stricmp(tag.s, "texture"      ) == 0) struct texture  tex <open=true, bgcolor=cWhite>;
        else if (Stricmp(tag.s, "shader"       ) == 0) struct shader   sha <open=true, bgcolor=cWhite>;
        else if (Stricmp(tag.s, "material"     ) == 0) struct material mat <open=true, bgcolor=cDkGreen>;
        else if (Stricmp(tag.s, "mesh"         ) == 0) struct mesh     mes <open=true, bgcolor=cDkRed>;
        else if (Stricmp(tag.s, "body"         ) == 0) struct body     bod <open=true, bgcolor=cDkBlue>;
        else if (Stricmp(tag.s, "skeleton"     ) == 0) struct skel     skl <open=true, bgcolor=cDkRed>;
        else if (Stricmp(tag.s, "skeleton_anim") == 0) struct skel_ani ska <open=true, bgcolor=cDkRed>;
        else if (Stricmp(tag.s, "end"          ) == 0);
    } section <optimize=false, open=true, read=read_brf>;
}

string read_ver(struct ver_t& _thing)
{
    return "- " + _thing.tex_name.s;
}
string read_tex(struct tex_t& _thing)
{
    return "- " + _thing.tex_name.s;
}
string read_sha(struct sha_t& _thing)
{
    return "- " + _thing.tex_name.s;
}
string read_mat(struct mat_t& _thing)
{
    return "- " + _thing.mat_name.s;
}
string read_mesh(struct mesh_t& _thing)
{
    string s =  "";
    
    SPrintf(s, "* %-80s", _thing.mesh_name.s);

    if (_thing.extra_frames > 0)
        SPrintf(s, "%s (%d vertex frames)", s, _thing.extra_frames + 1);

    if (_thing.bone_count > 0)
        SPrintf(s, "%s (skinned to %u bones)", s, _thing.bone_count); 

    return s;
}
string read_body(struct body_t& _thing)
{
    return "- " + _thing.body_name.s;
}
string read_skl(struct skl_t& _thing)
{
    return "* " + _thing.mesh_name.s;
}
string read_ska(struct ska_t& _thing)
{
    return "* " + _thing.mesh_name.s;
}
string read_brf(struct brf_section& _thing)
{
    return "[" + _thing.tag.s + "]";
}