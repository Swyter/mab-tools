<!DOCTYPE html>
<!-- MADE BY SWYTER ON THE THIRD QUARTER OF 2022
  -- MAKES USE OF A HTML5 COMPLIANT BROWSER, NO EXTERNALS -- HAVE FUN
  -- References: <http://mbmodwiki.ollclan.eu/SceneObj>
  -- Programs used: Notepad++ 5.9.8 with NppFTP, Chromium Dev Tools.
  -->
<html lang="en-EN"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <title>Swyter's Mount&amp;Blade Face code Generator | Just great.</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAG1BMVEUAAAAmJiZNTVRhXV9rZFt4ZmZ2dG2NcXqIioGHzHJjAAAAAXRSTlMAQObYZgAAAG5JREFUeNo1jdEJgDAMRNMNeqULeN1AEb8jRdzABUT8LriBg5so5ifHPV4iggBkRPF1AxBoXRSEhHxWZYPkfGpib6geyjJZs+4zizVhqYmlRYERDpuhO5GjW+aU7Q1Oml/mMF2dWSaR/uub+Ad5AL4eE+r2NulVAAAAAElFTkSuQmCC">
    <style type="text/css">
    html{
        background-color:#998;
        user-select:none;
        -webkit-user-select:none;
        -m//oz-user-select:none; /* if we use this one firefox makes buggy all our input boxes, meh */
        -o-user-select:none;
    }
    body{
        width: 777px;
        margin: 0 auto;
        padding: 45px;
        /*box-shadow:0 0 6px gray;*/
        box-shadow: 0 0 140px #776;
        
        background-color:#554;
        color:#eee;
        font-size:95%;
        font-family:serif;
        letter-spacing: 2px;
        
        border: 4px double #997;
        border-color:rgba(153, 153, 119, 0.73);
        border-top: 0;

        /* Colorzilla gradient */
        background: #777766;
        background: -moz-linear-gradient(-45deg, #777766 5%, #6d675e 100%);
        background: -webkit-gradient(linear, left top, right bottom, color-stop(5%,#777766), color-stop(100%,#6d675e));
        background: -webkit-linear-gradient(-45deg, #777766 5%,#6d675e 100%);
        background: -o-linear-gradient(-45deg, #777766 5%,#6d675e 100%);
        background: -ms-linear-gradient(-45deg, #777766 5%,#6d675e 100%);
        background: linear-gradient(-45deg, #777766 5%,#6d675e 100%);
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#777766', endColorstr='#6d675e',GradientType=1 );
    }
    
    label {
        width: inherit;
        display: inline-block;
        text-shadow: 1px 1px black;
        -moz-user-select:none; /* firefux clumsy behavior fix */
        display: table-cell;
        align-self: end;
        vertical-align: middle;
        width: max-content;
    }

    div#right-block label, div#right-block > button, div#right-block input[type=number] {
        padding: 6px;
    }

    div#right-block > section > button {
        width: 50%; display: inline-block;
        margin-right: 5px;
    }

    div#right-block > label > select, div#right-block input {
        width: 240px;
    }
    
    div#right-block {
        align-self: center;
        padding-right: 40px;
    }

    div#right-block section {
        display: flex;
        flex-direction: row;
        justify-content: end;
        margin-top: 18px;
        margin-left: 79px;
    }
    
    input,select, button{
        -webkit-user-select:unset;
        -m//oz-user-select:unset;
        -o-user-select:unset;
        
        font-family:times,serif;
        text-transform: lowercase;
    }

    input[type="range"] {
        position: relative;
        width: 120px;
        top: 7px;
    }
    
    input#thash{
        width:100%;
        text-align:center;
        font-size:140%;
        font-family:times,serif;
        font-style: oblique;
        text-transform: lowercase;
        box-shadow: 0 0 114px #89A;
    }
    
    input[type=checkbox]{
        width:0/*initial*/;
        padding-right:60px;
        color:gold;
        
        /*width: 46px;
        padding-right: 18px;
        color: gold;
        font-family: serif;
        letter-spacing: 1px;
        text-align: right;
        display: inline-block;
        text-shadow: 1px 1px 0 black;*/	
        
        padding-right: 28px;
        color: goldenrod;
        font-family: serif;
        letter-spacing: 1px;
        text-align: right;
        display: inline-block !important;
        text-shadow: 1px 1px 0 black;
        
        }input[type=checkbox]:after{
        content:'disabled';
        
        }input[type=checkbox]:checked:after{
        content:'enabled' !important;
        color: gold;
    }
    
    h1,h2,h3{
        font-weight: 100;
        text-shadow: 2px 1px black;
        margin:0;
        cursor:default;
        -moz-user-select:none; /* firefux clumsy behavior fix */
    }
    h3{margin-bottom: -29px;}
    h1{
        font-size: 3.6em;
        -webkit-mask: -webkit-linear-gradient(white,rgba(0,0,0,.5) 70%);
        -moz-mask: -moz-linear-gradient(white,rgba(0,0,0,.5) 70%);
    }
    h2{
        border-top: 1px solid #775;
        border-color:rgba(153, 153, 119, 0.42);
        margin-top: -32px;
        letter-spacing: .4em;
        padding-top: 9px;
        
        }h2>span{
        position:absolute;
        /*color:#BE4343;*/
        color:#DB6565;
        -webkit-transform: rotate(9deg); 
           -moz-transform: rotate(9deg);
        font-size: 15px;
        letter-spacing: 0/*initial*/;
        text-shadow: 0 0 14px red;
        margin-left: -194px;
        margin-top: -58px;
        font-weight: 700;
        opacity: .9;
        text-transform: uppercase;
        
        -webkit-animation-name: pulse; 
        -webkit-animation-duration: 0.5s; 
        -webkit-animation-iteration-count: 100; 
        white-space: nowrap;
        -moz-user-select:none; /* firefux clumsy behavior fix */
    }
    
    img[src*="w3"]{
        width:140px;
    }
    
    @-webkit-keyframes pulse {
      from {
        opacity: 1;
      }
      50% {
        opacity: .75;
      }
      to { 
        opacity: 1;
      }
    }
    
    #pol>option:after{
        content:' meters';
    }
    
    select,option{
        font-family: serif;
        letter-spacing: 1px;
    }
    
    input#thash{
        border: double 4px #89A;
    }

    div#droparea {
        width: 324px;
        display: inline-block;
        position: sticky;
        bottom: 0;
        left: 0;
        background: #884e2bb5;
        border: 6px double #bb826687;
        padding: 16px;
        right: 0px;
        bottom: 0;
        text-shadow: 1px 1px black;
        box-shadow: 0px 0px 42px #0000002e;
        margin-top: 30px;
    }

    div#right-block {

        float: left;

        display: flex;
        flex-direction: column;
        justify-content: right;
        padding: 5px;
    }

    div#right-block > input, div#right-block > select {
        width: 200px;
    }
    div#left-block {
        display: block;
        position: relative;
        overflow: hidden scroll;
        white-space: normal;

        margin-top: 2px;
        border-top: 2px dotted #998;
        border-right: 2px dotted #998;
        background: linear-gradient(225deg, #9999884f 5%, transparent 30%);

        padding: 41px;
        padding-top: 0;
        display: flex;
        flex-direction: column;
        justify-content: right;

        height: calc( - 300px);
    }

    body:after {
        content: "";
        display: table;
        clear: both;
    }

    fieldset {
        border: 5px double #bb8266;
        white-space: initial;
    }

    div#ascii {
        white-space: pre-line;
        top: 0;
        z-index: 99;
    }

    button, select {
        padding: 6px;
    }

    /* swy: make it clear when the input code is wrong by reddening the input background,
            see the pattern and maxlength/minlength attributes in thash <input> */
    :invalid { background: rgb(238, 203, 203); }
    </style>
</head>
<body>
    <div id="ascii">
    <h3>— the one and only —</h3>
    <h1>face code generator</h1>
    <h2>who needs the game, anyway?<span>Ten year anniversary!</span></h2>
    <input id="thash" type="text" placeholder="~Paste your hash here~" data-kpxc-id="thash" value="0x000000000000000036db6db6db6db6dbb6db6db6db6db6db0000000000000000" autofocus maxlength=66 minlength=66 pattern='0x[0-9a-f]{64}' title='Insert some hexadecimal 64-digit face code starting with the «0x» prefix.'>
    </div>
    <div id="right-block">
        <label>skin           <input type="number" id="ski" min="0" max="63" value="0"> </label>
        <label>beard          <input type="number" id="bea" min="0" max="63" value="0"> </label>
        <label>hair           <input type="number" id="hai" min="0" max="63" value="0"> </label>
        
        <label>age            <input id="age" type="range" min="0" max="63" value="18"> </label>
        <label>hair color     <input id="col" type="range" min="0" max="63" value="42"> </label>

        <section><button id=rnd>randomize</button> <button id=rst>reset</button></section>

        <div id=droparea>
            Drag and drop here your mod's <tt>skins.txt</tt> file to use it as template...
            
            <label>choose a race: <select id=racesel disabled></select></label>
            <fieldset>
                <legend>template stuff</legend>
                <button id=usenat disabled>use «native» as template</button>
                <button id=delsav disabled>delete saved race template and view raw fields</button>
            </fieldset>
        </div>
    </div>

    <!--input type="range" min="0" max="50" value="25" step="5" /-->
    <div id="left-block">
        <label>face key 42  <input id="fk42" type="range" min="0" max="1" value="0"></label> <!-- count: 21 - cleared skin3 leftmost, only has one bit, i think -->

        <label>face key 41  <input id="fk41" type="range" min="0" max="7" value="0"></label>
        <label>face key 40  <input id="fk40" type="range" min="0" max="7" value="0"></label>
        <label>face key 39  <input id="fk39" type="range" min="0" max="7" value="0"></label>
        <label>face key 38  <input id="fk38" type="range" min="0" max="7" value="0"></label>
        <label>face key 37  <input id="fk37" type="range" min="0" max="7" value="0"></label>
        <label>face key 36  <input id="fk36" type="range" min="0" max="7" value="0"></label>
        <label>face key 35  <input id="fk35" type="range" min="0" max="7" value="0"></label>
        <label>face key 34  <input id="fk34" type="range" min="0" max="7" value="0"></label>
        <label>face key 33  <input id="fk33" type="range" min="0" max="7" value="0"></label>
        <label>face key 32  <input id="fk32" type="range" min="0" max="7" value="0"></label>
        <label>face key 31  <input id="fk31" type="range" min="0" max="7" value="0"></label>
        <label>face key 30  <input id="fk30" type="range" min="0" max="7" value="0"></label>
        <label>face key 29  <input id="fk29" type="range" min="0" max="7" value="0"></label>
        <label>face key 28  <input id="fk28" type="range" min="0" max="7" value="0"></label>
        <label>face key 27  <input id="fk27" type="range" min="0" max="7" value="0"></label>
        <label>face key 26  <input id="fk26" type="range" min="0" max="7" value="0"></label>
        <label>face key 25  <input id="fk25" type="range" min="0" max="7" value="0"></label>
        <label>face key 24  <input id="fk24" type="range" min="0" max="7" value="0"></label>
        <label>face key 23  <input id="fk23" type="range" min="0" max="7" value="0"></label>
        <label>face key 22  <input id="fk22" type="range" min="0" max="7" value="0"></label>
        <label>face key 21  <input id="fk21" type="range" min="0" max="7" value="0"></label> <!-- count: 22 - skin_3 begins -->

        <label>face key 20  <input id="fk20" type="range" min="0" max="7" value="0"></label> <!-- count: 21 - cleared skin2 leftmost -->
        <label>face key 19  <input id="fk19" type="range" min="0" max="7" value="0"></label>
        <label>face key 18  <input id="fk18" type="range" min="0" max="7" value="0"></label>
        <label>face key 17  <input id="fk17" type="range" min="0" max="7" value="0"></label>
        <label>face key 16  <input id="fk16" type="range" min="0" max="7" value="0"></label>
        <label>face key 15  <input id="fk15" type="range" min="0" max="7" value="0"></label>
        <label>face key 14  <input id="fk14" type="range" min="0" max="7" value="0"></label>
        <label>face key 13  <input id="fk13" type="range" min="0" max="7" value="0"></label>
        <label>face key 12  <input id="fk12" type="range" min="0" max="7" value="0"></label>
        <label>face key 11  <input id="fk11" type="range" min="0" max="7" value="0"></label>
        <label>face key 10  <input id="fk10" type="range" min="0" max="7" value="0"></label>
        <label>face key 09  <input id="fk09" type="range" min="0" max="7" value="0"></label>
        <label>face key 08  <input id="fk08" type="range" min="0" max="7" value="0"></label>
        <label>face key 07  <input id="fk07" type="range" min="0" max="7" value="0"></label>
        <label>face key 06  <input id="fk06" type="range" min="0" max="7" value="0"></label>
        <label>face key 05  <input id="fk05" type="range" min="0" max="7" value="0"></label>
        <label>face key 04  <input id="fk04" type="range" min="0" max="7" value="0"></label>
        <label>face key 03  <input id="fk03" type="range" min="0" max="7" value="0"></label>
        <label>face key 02  <input id="fk02" type="range" min="0" max="7" value="0"></label>
        <label>face key 01  <input id="fk01" type="range" min="0" max="7" value="0"></label>
        <label>face key 00  <input id="fk00" type="range" min="0" max="7" value="0"></label> <!-- count: 1 - skin2 begins -->
    </div>
    <script type="text/javascript">
    /* basic helpers */
    app = document;
    function _(e){return console.log(e);}
    function $(e){return app.getElementById(e);} //who needs jquery anyways? :P
    
    //! http://stackoverflow.com/a/202627
    String.prototype.repeat=function( num ){ return new Array( num + 1 ).join( this );}
    
    //! http://www.2ality.com/2012/02/js-integers.html
    String.prototype.frombin = function ( ) { return parseInt(this,  2);};
    String.prototype.fromdec = function ( ) { return parseInt(this, 10);};
    String.prototype.fromhex = function ( ) { return parseInt(this, 16);};
    Number.prototype.tobin   = function ( ) { var sign = (this < 0 ? "-" : "");var result = Math.abs(this).toString(2);while(result.length < 32) {result = "0" + result;}return sign + result;}
    Number.prototype.tohex   = function ( ) { return this.toString(16);};
    String.prototype.pad     = function (n) { var result=this;while(result.length < n) {result = "0" + result;} return result;}
    
    /* get elements */
    thash=$('thash');
    
    ski=$('ski');
    bea=$('bea');
    hai=$('hai');

    age=$('age');
    col=$('col');
    
    fk42=$('fk42');
    fk41=$('fk41');	fk20=$('fk20');
    fk40=$('fk40');	fk19=$('fk19');
    fk39=$('fk39');	fk18=$('fk18');
    fk38=$('fk38');	fk17=$('fk17');
    fk37=$('fk37');	fk16=$('fk16');
    fk36=$('fk36');	fk15=$('fk15');
    fk35=$('fk35');	fk14=$('fk14');
    fk34=$('fk34');	fk13=$('fk13');
    fk33=$('fk33');	fk12=$('fk12');
    fk32=$('fk32');	fk11=$('fk11');
    fk31=$('fk31');	fk10=$('fk10');
    fk30=$('fk30');	fk09=$('fk09');
    fk29=$('fk29');	fk08=$('fk08');
    fk28=$('fk28');	fk07=$('fk07');
    fk27=$('fk27');	fk06=$('fk06');
    fk26=$('fk26');	fk05=$('fk05');
    fk25=$('fk25');	fk04=$('fk04');
    fk24=$('fk24');	fk03=$('fk03');
    fk23=$('fk23');	fk02=$('fk02');
    fk22=$('fk22');	fk01=$('fk01');
    fk21=$('fk21');	fk00=$('fk00');

    racesel=$('racesel');
    rnd=$('rnd');
    rst=$('rst');

    usenat=$('usenat');
    delsav=$('delsav');

    /* basic functions */
    
    var hash   = {}
    var struct = {
    //value       //key no. //shift //num bits     //input        //WORKING FINE?
    hair          : [0,      0,      6,            hai        ], // max bits known, adjacent to next left field (beard)
    beard         : [0,      6,      6,            bea        ], // max bits known, adjacent to next left field (skin)
    skin          : [0,     12,      6,            ski        ], // ¡! check max bits for correctness
    hair_color    : [0,     24,      6,            col        ], // max bits known, adjacent to next left field (age)
    age           : [0,     30,      6,            age        ], // ¡! check max bits for correctness

    facekey00     : [1,   3* 0,      3,           fk00        ], //yay -
    facekey01     : [1,   3* 1,      3,           fk01        ], //yay -
    facekey02     : [1,   3* 2,      3,           fk02        ], //yay -
    facekey03     : [1,   3* 3,      3,           fk03        ], //yay -
    facekey04     : [1,   3* 4,      3,           fk04        ], //yay -
    facekey05     : [1,   3* 5,      3,           fk05        ], //yay -
    facekey06     : [1,   3* 6,      3,           fk06        ], //yay -
    facekey07     : [1,   3* 7,      3,           fk07        ], //yay -
    facekey08     : [1,   3* 8,      3,           fk08        ], //yay -
    facekey09     : [1,   3* 9,      3,           fk09        ], //yay -
    facekey10     : [1,   3*10,      3,           fk10        ], //yay -
    facekey11     : [1,   3*11,      3,           fk11        ], //yay -
    facekey12     : [1,   3*12,      3,           fk12        ], //yay -
    facekey13     : [1,   3*13,      3,           fk13        ], //yay -
    facekey14     : [1,   3*14,      3,           fk14        ], //yay -
    facekey15     : [1,   3*15,      3,           fk15        ], //yay -
    facekey16     : [1,   3*16,      3,           fk16        ], //yay -
    facekey17     : [1,   3*17,      3,           fk17        ], //yay -
    facekey18     : [1,   3*18,      3,           fk18        ], //yay -
    facekey19     : [1,   3*19,      3,           fk19        ], //yay -
    facekey20     : [1,   3*20,      3,           fk20        ], //yay -

    facekey21     : [2,   3* 0,      3,           fk21        ], //yay -
    facekey22     : [2,   3* 1,      3,           fk22        ], //yay -
    facekey23     : [2,   3* 2,      3,           fk23        ], //yay -
    facekey24     : [2,   3* 3,      3,           fk24        ], //yay -
    facekey25     : [2,   3* 4,      3,           fk25        ], //yay -
    facekey26     : [2,   3* 5,      3,           fk26        ], //yay -
    facekey27     : [2,   3* 6,      3,           fk27        ], //yay -
    facekey28     : [2,   3* 7,      3,           fk28        ], //yay -
    facekey29     : [2,   3* 8,      3,           fk29        ], //yay -
    facekey30     : [2,   3* 9,      3,           fk30        ], //yay -
    facekey31     : [2,   3*10,      3,           fk31        ], //yay -
    facekey32     : [2,   3*11,      3,           fk32        ], //yay -
    facekey33     : [2,   3*12,      3,           fk33        ], //yay -
    facekey34     : [2,   3*13,      3,           fk34        ], //yay -
    facekey35     : [2,   3*14,      3,           fk35        ], //yay -
    facekey36     : [2,   3*15,      3,           fk36        ], //yay -
    facekey37     : [2,   3*16,      3,           fk37        ], //yay -
    facekey38     : [2,   3*17,      3,           fk38        ], //yay -
    facekey39     : [2,   3*18,      3,           fk39        ], //yay -
    facekey40     : [2,   3*19,      3,           fk40        ], //yay -
    facekey41     : [2,   3*20,      3,           fk41        ], //yay -
    facekey42     : [2,   3*21,      1, /*<- ! */ fk42        ], /* swy: only one bit left, wonky slider in-game; why not exploit the remaining range better? Don't ask me */
}

/*

 face_key_1 = 180000041
 face_key_2 = 36db79b6db6db6fb
                                                 

                                  <------- start-|
                  <------- start-|               |
  <------- start-|               |               |
0x000000018000004136db79b6db6db6fb7fffff6d77bf36db0000000000000000
  _______180000041
       (0)        36db79b6db6db6fb
                        (1)       7fffff6d77bf36db
                                        (2)       ----------------
                                                         (3)
                                                       (unused)

  Here is block (0) from the example above, we will use the bit shift and number of bits columns
  from the table below to build bitmasks and retrieve each field, using the Python 3 prompt:

  For example, age is in block (0), has 6 bits and a shift of 30 bits,
  using hex((pow(2, num_bits) - 1) << bit_shift) we get:

    >>> hex((pow(2,6)-1) << 30)
    '0xfc0000000'
    >>> hex((pow(2,6)-1))
    '0x3f'

    >>> bin((pow(2,6)-1) << 30) # swy: same thing, but in binary
    '0b111111000000000000000000000000000000'
    >>> bin((pow(2,6)-1)) # swy: what this does is just to generate six ones, six bits
    '0b111111'

  Now that we have the right bitmask we can use the logical AND operation to isolate only the bits
  we are interested in and shift them back to the right (we can also see it as removing the padding)
  to get the actual number with just a simple ((block & bitmask) >> bit_shift):

    >>> hex(0x180000041 & 0xfc0000000) # swy: only leave our six potential bits toggled
    '0x180000000'
    >>> bin(0x180000041 & 0xfc0000000) # swy: same thing, but in binary
    '0b110000000000000000000000000000000'
    >>> bin(0x180000041)               # swy: here's the original, compare against the one above
    '0b110000000000000000000000001000001'

    >>> hex((0x180000041 & 0xfc0000000) >> 30) # swy: we are interested in the left-most «110» bit part you see above
    '0x6'
    >>> bin((0x180000041 & 0xfc0000000) >> 30) # swy: so move the bits 30 positions to the right, same but shown in binary
    '0b110'

    >>> ((0x180000041 & 0xfc0000000) >> 30)
    6

||    Do:  0000000000000000000000000000000110000000000000000000000001000001
 |  Mask:  ----------------------------XXXXXX
 | Final:                              000110

  In our case the age field contains the number six. See more examples below.

  _______180000041
                3f # hair: to get the field ((0x180000041 & 0x3f) >> 0), which results in 1
               fc0 # beard
             3f000 # skin
          3f000000 # hair_color: to get the field ((0x180000041 & 0x3f000000) >> 24), which results in 0
         fc0000000 # age: python code to generate a bitmask: hex((pow(2,6)-1) << 30)
*/

    app.onclick = function(e)
    {
        console.log(e);

        switch (e.target)
        {
            case rnd: /* swy: the age slider doesn't move, hidden/empty/unused key morphs are set to zero by the game, same below */
                /* swy: convert the NodeList into an array so that we can reverse what's already reversed */
                var labels = document.querySelectorAll(`input[id^=fk]`);
                labels = Array.from(labels).reverse();

                for (var cur of labels)
                {
                    associated_label = cur.parentNode;
                    if (associated_label && associated_label.textContent == '<hidden> ')
                        cur.value = 0;
                    else
                        cur.value = Math.random() * cur.max;
                    app.onchange({ target: cur });
                }

                /* swy: make it only randomize when we actually have a combobox with the maximum amount
                        of meshes, at least for now. I don't think it would make too much sense */
                if (ski.options && ski.options.length > 0)
                {
                    ski.value = ski.options[Math.round(Math.random() * Math.max(ski.options.length - 1, 0))].value;
                    app.onchange({ target: ski });
                }
                if (bea.options && bea.options.length > 0)
                {
                    bea.value = bea.options[Math.round(Math.random() * Math.max(bea.options.length - 1, 0))].value;
                    app.onchange({ target: bea });
                }
                if (hai.options && hai.options.length > 0)
                {
                    hai.value = hai.options[Math.round(Math.random() * Math.max(hai.options.length - 1, 0))].value;
                    app.onchange({ target: hai });
                }

                col.value = Math.random() * col.max;
                app.onchange({ target: col });

                break;

            case rst:
                /* swy: convert the NodeList into an array so that we can reverse what's already reversed */
                var labels = document.querySelectorAll(`input[id^=fk]`);
                labels = Array.from(labels).reverse();

                for (var cur of labels)
                {
                    associated_label = cur.parentNode;
                    if (associated_label && associated_label.textContent == '<hidden> ')
                        cur.value = 0;
                    else
                        cur.value = (cur.max - .5) / 2; /* swy: the game rounds downwards and always ends up with 3 instead of 4 */
                    app.onchange({ target: cur });
                }
                break;
            case usenat:
                download_and_set_up_native_skins();
                break;
            case delsav:
                delete localStorage.race;
                delete localStorage.race_ver;
                window.location.hash = thash.value;
                localStorage.raw_view = true;
                location.reload();
                break;
        }
    }

    /* handlers */
    app.onchange = function(e)
    {
        switch (e.target)
        {
            case thash: 
                _('a new hash has arrived!');
                _parse(thash.value);
                break;
            case racesel:
                localStorage.cur_race_idx = e.target.value;
                set_up_dyn_interface();
                break;
            default:
                _(e.target.id+" has changed");
        }

        for (var key in struct)
        {
            /* swy: not this element? skip it */
            if (e.target != struct[key][3])
                continue;

            /* --- */

            if (e.target.type == "checkbox")
                _out = e.target.checked ? 1 : 0;
            else
                _out = e.target.value;

            _("I've found a new value to change: "+_out);
            
            key_no   = struct[key][0];
            shift    = struct[key][1];
            num_bits = struct[key][2];
            
            
            _outbin = String(_out).fromdec().tobin();
            //_outbin = String('00000000000000000000000000000000'+_outbin
            //	).slice(-num_bits);

            _bin  = hash[ key_no ].substr(0, 8).fromhex().tobin() /* swy: "0000000fc0001000".substr(0, 8):          c0001000 */
            _bin += hash[ key_no ].substr(8, 8).fromhex().tobin() /*      "0000000fc0001000".substr(8, 8):  0000000f         */


            //_bin = String('00000000000000000000000000000000'+_bin
            //	).slice(_bin.length);
            
            _cut = _bin.substr( -(shift+num_bits), num_bits );
            
            base= _bin.length;
            basb= _cut.length;
            
            _("//key no. //shift //num bits");
            _("|| Struct: " + struct[key]);
            _("     base: " + base);
            _("    shift: " + shift);
            _('||    Do:  ' + ('-').repeat( (64-base) ) + _bin );


            _(' |  Mask:  ' + ('-').repeat( 64-(num_bits)-(shift) ) + ('X').repeat( (num_bits) ) );
            _(' | Final:  ' + (' ').repeat( 64-(num_bits)-(shift) ) + _outbin.substr(-num_bits) );
            _(' |  Prev:  ' + (' ').repeat( 64-(num_bits)-(shift) ) + _cut );
            
            //Reset the enabled bitmask values by XOR'ing them with themselves...
            /*-->
            
            _reset= ( _bin.frombin() ) ^ ( _cut.frombin() << shift );
            _(' | Reset:  '  + _reset.tobin() );

            //Add the new values by OR'ing them with the noew blank shift range/scope...
            _added= ( _reset | _out << shift);
            _(' | Added:  '  + _added.tobin() );
            
            <--*/
            
            //There's a limitation in bitwise operations in js: 32 bit signed integers, so if we set the last bit it turns out negative :/
            //_outhack = (_out << shift).tobin().substr( -(shift+num_bits), num_bits );
            
            _("----------");
            _("    out:" + _out);
            _outhack = Number(_out).tobin().substr( -(num_bits), num_bits );
            _("outhack:" + _outhack);
            _("togther:" + _bin.substr(0, 64-(num_bits+shift))+"|"+_outhack.substr(-num_bits)+"|"+_bin.substr(-shift,shift))
            _("----------");
            
            hash_bin = (
                    /* 1st orig. chunk */		_bin.substr(0, 64-(num_bits+shift) ) +
                    /* our modif. part */	_outhack.substr(-num_bits) +
                    /* 2nd orig. chunk */	    _bin.substr(-shift,shift)
                            
                            );
            hash[key_no]  = hash_bin.substr( 0, 32).frombin().tohex().pad(8);
            hash[key_no] += hash_bin.substr(32, 32).frombin().tohex().pad(8);
                            
            if (e.target.attributes[4]) {
                e.target.attributes[4].value=_out; //manages the display of the values in sliders
            }
            
            thash.value='0x'+(hash[0] + hash[1] + hash[2] + hash[3]);
            //_parse(thash.value);

            /* swy: update the URL so that the user can click backwards and forwards and get undo and redo functionality,
                    while also having a nice copy-able permalink with the current state */
            if (window.location.hash != thash.value)
                window.location.hash = thash.value;
            break;
        }
    }
    
//	app.onkeydown=function(e)
//	{
//		/* swy: only react to the Enter key */
//		if (e.keyIdentifier == 'Enter' || e.keyCode == 13) //firefux doesn't supprts keyIdentifier, of course :(
//		{
//			//if (e.target!=flseed && e.target!=riseed && e.target!=teseed){return 0;}
//			_("boom");
//			//! http://stackoverflow.com/a/6005163
//			e.target.value = Math.floor(Math.random() * ( 65535 /* even better, 4 ones, as the game does 1048575/* use half of the bitmask instead 2147483647*/ + 1));
//			app.onchange(e); // we've to force a new state so the app knows that the randomization has been launched by the user :)
//		}
//	}
    
    function _parse(e)
    {
        e=e.replace('0x','');
        if (e.length != 64)
        {
            _("badly formatted hash :(");
            return false; //doesn't validate
        }
        
        for (var i=1; i<=4; i++) // 4 64-bit chunks == 8 32-bit chunks
            hash[3-(i-1)] = /*parseInt(*/e.substr(-16*i,16)/*, 16).toString(2)*/;

        //https://ricochen.wordpress.com/2010/04/24/javascript-zero-padding-numbers/
        //String('00000'+n).slice(-5);
        _(e);
        _(hash[0] + hash[1] + hash[2] + hash[3]);
        
        
        for (var key in struct)
        {
            _("---");
            _("||    Key: " + key);
            _("//key no. //shift //num bits");
            _("|| Struct: " + struct[key]);
          
            key_no   = struct[key][0];
            shift    = struct[key][1];
            num_bits = struct[key][2];

            /* swy: split them in two because the fromhex() and tobin() functions can't
                    really handle more than 32 bits at a time */
            _bin  = hash[ key_no ].substr(0, 8).fromhex().tobin() /* swy: "0000000fc0001000".substr(0, 8):          c0001000 */
            _bin += hash[ key_no ].substr(8, 8).fromhex().tobin() /*      "0000000fc0001000".substr(8, 8):  0000000f         */
            _bin = _bin.pad(_bin.length);

            _cut = _bin.substr( -(shift+num_bits), num_bits );

            base= _bin.length;
            basb= _cut.length;
            _("     base: " + base);
            _("    shift: " + shift);


            _('||    Do:  '  + ('-').repeat( (64-base) ) + _bin );


            _(' |  Mask:  '  + ('-').repeat( 64-(num_bits)-(shift) ) + ('X').repeat( (num_bits) ) );
            //_('||       '  + ('-').repeat( (64-base) ) + ('.').repeat( (64-base)+(64-basb)-2 ) + _cut );
            _(' | Final:  '  + (' ').repeat( 64-(num_bits)-(shift) ) + _cut );

            _dec = _cut.frombin();
            _('');
            _('|| Decim: ' + _dec);
            _bool= ((_dec==0) ? false : true );
            _('||  Bool: ' + _bool);

            _( struct[key][1]*struct[key][0]+" / size: " + struct[key][2]);

            //update our controls
            struct[key][3].value=_dec;

            if (struct[key][3].attributes[4])
                struct[key][3].attributes[4].value=_dec; //manages the display of the values in sliders

            //if (_bool){
            struct[key][3].checked=_bool;
            //}
        }
    }

    //! dbg----
    window.onload = function()
    {
        if (window.location.hash == '')
        {
            def = '0x000000000000000036db6db6db6db6dbb6db6db6db6db6db0000000000000000';
            thash.value = def;
            _parse(def);
        }
        else
            window.onhashchange();
    }
    
    //! permalink
    window.onhashchange = function()
    {
        def=window.location.hash.replace('#', '');
        thash.value = def;
        _parse(def);
    }

    function parse_skins_txt(text_file)
    {
        var state = 'MAGIC'; race = []; /* swy: reset the global race holder */
        localStorage.cur_race_idx = 1;
        var race_count = 0;
        var cur_race_idx = 0;
        var cur_hair_count = 0;
        var cur_beard_count = 0;

        var txt = text_file.replace(/\r/g, '').split('\n');

        for (var linetxt of txt)
        {
            var line = linetxt.replace(/[\t ]+/g, ' ').replace(/^[ ]*/g, '').replace(/[ ]*$/g, '').split(' ');
            console.log(line);

            switch (state)
            {
                case 'MAGIC':
                {
                    if (state == 'MAGIC' && linetxt == 'skins_file version 1')
                        state = 'READ_RACE_COUNT';
                    else
                    {
                        console.warn(`swy: bad file magic value: ${linetxt}`);
                        break;
                    }
                }
                break;

                case 'READ_RACE_COUNT':
                {
                    race_count = +line[0];
                    state = 'READ_RACE_NAME';
                }
                break;

                case 'READ_RACE_NAME':
                {
                    if (!line || line[0] == undefined || line.length < 2)
                        continue;

                    race[cur_race_idx]={};
                    race[cur_race_idx]["name"] = line[0];
                    race[cur_race_idx]["unk_number"] = +line[1];
                    state = 'READ_RACE_MESHES';
                }
                break;

                case 'READ_RACE_MESHES':
                {
                    race[cur_race_idx]["mesh_body"] = line[0];
                    race[cur_race_idx]["mesh_calf"] = line[1];
                    race[cur_race_idx]["mesh_hand"] = line[2];
                    state = 'READ_RACE_HEAD';
                }
                break;

                case 'READ_RACE_HEAD':
                {
                    race[cur_race_idx]["mesh_head"] = line[0];
                    race[cur_race_idx]["face_keys"] = [];

                    var face_key_count = line[1];

                    for (i = 0, idx = 2; i < face_key_count; i++, idx += 6)
                        race[cur_race_idx]["face_keys"].push({
                            id: line[idx],
                            a: line[idx + 1],
                            b: line[idx + 2],
                            c: line[idx + 3],
                            d: line[idx + 4],
                            tag: line[idx + 5].replace(/_/g, ' ')
                        }); /* swy: the data starts at line[2] */

                    state = 'READ_RACE_HAIR_COUNT';
                }
                break;

                case 'READ_RACE_HAIR_COUNT':
                {
                    cur_hair_count = +line[0];
                    state = 'READ_RACE_HAIR';
                }
                break;

                case 'READ_RACE_HAIR':
                {
                    race[cur_race_idx]["mesh_hair"] = [];

                    for (i = 0; i < cur_hair_count; i++)
                        race[cur_race_idx]["mesh_hair"].push(line[i]);

                    state = 'READ_RACE_BEARD_COUNT';
                }
                break;

                case 'READ_RACE_BEARD_COUNT':
                {
                    cur_beard_count = +line[0];
                    state = 'READ_RACE_BEARD';
                }
                break;

                case 'READ_RACE_BEARD':
                {
                    if (!race[cur_race_idx]["mesh_beard"])
                        race[cur_race_idx]["mesh_beard"] = [];

                    race[cur_race_idx]["mesh_beard"].push(line[0]);

                    if (--cur_beard_count <= 0)
                        state = 'READ_RACE_HAIR_MATERIALS';
                }
                break;

                case 'READ_RACE_HAIR_MATERIALS':
                {
                    race[cur_race_idx]["mat_hair"] = [];
                    hair_mat_count = line[0];

                    /* swy: skip the empty line */
                    if (hair_mat_count <= 0)
                        continue;

                    for (i = 0; i < hair_mat_count; i++)
                        race[cur_race_idx]["mat_hair"].push(line[1 + i]);

                    state = 'READ_RACE_BEARD_MATERIALS';
                }
                break;

                case 'READ_RACE_BEARD_MATERIALS':
                {
                    race[cur_race_idx]["mat_beard"] = [];
                    beard_mat_count = +line[0];

                    for (i = 0, idx = 1; i < beard_mat_count; i++, idx += 1)
                        race[cur_race_idx]["mat_beard"].push(line[idx]); /* swy: the data starts at line[1] */

                    state = 'READ_RACE_FACE_MATERIALS';
                }
                break;

                case 'READ_RACE_FACE_MATERIALS':
                {
                    race[cur_race_idx]["mat_skin"] = [];
                    face_mat_count = +line[0];
                    var size_of_cur_colors_block = 0;

                    for (i = 0, idx = 1; i < face_mat_count; i++, idx += 5 + size_of_cur_colors_block)
                    {
                        size_of_cur_colors_block = +line[idx + 3]; /* swy: convert to number, careful about this */
                        race[cur_race_idx]["mat_skin"].push(line[idx]);
                    }

                    state = 'READ_RACE_SOUNDS';
                }
                break;

                case 'READ_RACE_SOUNDS':
                {
                    race[cur_race_idx]["sounds"] = [];
                    sounds_count = line[0]; const constant_lookup = ['die', 'hit', 'grunt', 'grunt_long', 'yell', 'warcry', 'victory', 'stun'];

                    for (i = 0, idx = 1; i < sounds_count; i++, idx += 2)
                        race[cur_race_idx]["sounds"].push({type: constant_lookup[line[idx]], name: line[idx + 1]});

                    state = 'READ_RACE_SKELETON';
                }
                break;

                case 'READ_RACE_SKELETON':
                {
                    race[cur_race_idx]["skeleton"] = { name: line[0], scale: line[1] };
                    state = 'READ_RACE_UNK';
                }
                break;

                case 'READ_RACE_UNK':
                {
                    state = 'READ_RACE_RESTRICTIONS_COUNT';
                }
                break;

                case 'READ_RACE_RESTRICTIONS_COUNT':
                {
                    cur_restrictions_count = +line[0];
                    state = 'READ_RACE_RESTRICTIONS';
                }
                break;

                case 'READ_RACE_RESTRICTIONS':
                {
                    if (line[0] == undefined)
                        continue;

                    if (cur_restrictions_count-- <= 0)
                    {
                        console.warn(line);

                        /* swy: we're done for this entry, start parsing the next one, if any */
                        console.log(">> parsed race: ", race[cur_race_idx]);
                        state = 'READ_RACE_NAME';
                        cur_race_idx++; /* swy: self-increment here in the tail instead of doing it in the head, just before creating the next entry; if we self-increment in READ_RACE_NAME we'll end up with index zero (race[0] is always {}) empty. we could also initialize the index to -1 so that ends up as 0 the first time around */
                    }
                }
                break;
            }
            
        }

        localStorage.race = JSON.stringify(race);
        localStorage.race_ver = 20220809; /* swy: so that we can reset the saved that should we change the format */
        localStorage.raw_view = false;
    }

    function set_up_dyn_interface()
    {
        /* swy: convert the NodeList into an array so that we can reverse what's already reversed */
        var labels = document.querySelectorAll(`div#left-block label`);
        labels = Array.from(labels).reverse();

        var race_to_use = race[localStorage.cur_race_idx]; /* swy: orc on TLD */

        if (!race_to_use)
        {
            console.error(`swy: this race does not exist`, race_to_use);
            return;
        }

        for (var cur_label of labels)
        {
            var cur_index = labels.indexOf(cur_label);

            /* swy: usually a skin only uses a subset of the available face keys,
                    hide the rest if they go beyond what's available */
            if ((cur_index + 1) <= race_to_use.face_keys.length)
                cur_label.childNodes[0].nodeValue = race_to_use.face_keys[cur_index].tag + ' ';
            else
                cur_label.childNodes[0].nodeValue = '<hidden> ';
        }

        function replace_with_combobox(input_elem_name, fill_options)
        {
            original_elem = struct[input_elem_name][3];
            original_id   = original_elem.id;

            var sel = document.createElement('select'); sel.id = original_id;
            original_elem.replaceWith(sel);

            /* swy: replace the reference that is used to map input elements to code fields */
            struct[input_elem_name][3] = sel;

            /* swy: take advantage that the global variable (window is the global context)
                    has the same name as the tag id and replace it globally, too */
            window[original_id] = sel;

            if (!fill_options || fill_options.length == 0)
                console.error(`swy: seems like the skins.txt parser broke and no ${input_elem_name} options are returned.`, fill_options);

            for (var cur of fill_options)
            {
                var opt = document.createElement('option');
                opt.textContent = cur;
                opt.value       = fill_options.indexOf(cur);
                sel.appendChild(opt);
            }
        }

        replace_with_combobox("skin",  race_to_use.mat_skin);
        replace_with_combobox("beard", race_to_use.mesh_beard);
        replace_with_combobox("hair",  race_to_use.mesh_hair);


        var sel = document.createElement('select'); sel.id = racesel;
        racesel.replaceWith(sel);

        for (var i in race)
        {
            var cur = race[i]; /* swy: doesn't for of work here, it returns undefined. wtfbbq?? */

            if (cur == undefined)
                continue;

            console.log(cur.name, cur);

            var opt = document.createElement('option');
            opt.textContent = cur.name;
            opt.value       = race.indexOf(cur);
            sel.appendChild(opt);
        }

        sel.value = localStorage.cur_race_idx;
        racesel = sel;

        /* -- */

        /* swy: we've populated the interface contents with the template; toggle on both buttons,
                so that we can delete the template or go back to Native's skins.txt */
        usenat.disabled = false;
        delsav.disabled = false;
    }

    function download_and_set_up_native_skins()
    {
        /* swy: download and use Warband Native's version of skins.txt */
        xhr = new XMLHttpRequest;
        xhr.open('GET', 'https://gist.githubusercontent.com/Swyter/0b03cdae54886afc5ff2e51f3d8f1223/raw/383bc333829c2867132a9737d2079798c38cd73c/skins.txt');
        xhr.onloadend = function(e)
        {
            if (e.target.readyState != e.target.DONE)
                return;

            if (e.target.status != 200)
            {
                console.warn(`swy: couldn't download the file`, e);
                return;
            }

            parse_skins_txt(e.target.response);

            set_up_dyn_interface();
            console.log(e);
        }
        xhr.send();
    }

    
    race = [];

    if (!localStorage.raw_view || localStorage.raw_view == 'false')
    {
        /* swy: do we have some persistently-saved data from a mod in store? use it, otherwise it's probably the first time
                someone loads the tool and downloading the Native mod's skins.txt seems like a good idea */
        if (localStorage.race_ver && localStorage.race)
        {
            race = JSON.parse(localStorage.race)
            set_up_dyn_interface();
        }
        else
            download_and_set_up_native_skins();
    }
    else
    {
        /* swy: we're in raw mode; let the user download the Native template by toggling it on,
                but as there's no data to delete, gray out that button */
        usenat.disabled = false;
        delsav.disabled = true;
    }


    /* swy: grab/load a user-provided skins.txt via drag-and-drop */
    droparea = document.querySelector("div#droparea")
    droparea.ondrop = function(e)
    {
        e.preventDefault();
        console.log(e, e.dataTransfer.files[0], e.dataTransfer.files[0].kind);

        for (var cur_file of e.dataTransfer.files)
        {
            console.log("swy: dropped file:", cur_file.name, cur_file.type, cur_file);

            if (cur_file.type != 'text/plain' || cur_file.name != 'skins.txt')
                continue;

            console.warn("swy: this file seems right...");

            const reader = new FileReader();
            reader.onload = function(e)
            {
                console.log(e);

                if (e.target.readyState != reader.DONE)
                    console.warn(`swy: error while reading the drag-and-drop text...`, e);

                parse_skins_txt(e.target.result);
                set_up_dyn_interface()
            }
            reader.readAsText(cur_file);
            return;
        }

        alert("Please only drop one single «skins.txt» file from any Mount&Blade 1.011 or Warband-based mod.");
    }
    /* swy: we need to handle this or the dropped file will replace the current page */
    droparea.ondragover = function(e) { e.preventDefault();	}

    </script>
</body></html>