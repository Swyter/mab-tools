//------------------------------------------------
//--- 010 Editor v10.0 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

LittleEndian();

struct
{
    char magic[4];
    int ver;
    int spr_count;
} head <open=true>;

struct spr_t
{
    enum <uint32> 
    {
        Prop    = 0, /* Scene Prop */
        Entry   = 1, /* Entry Point */
        Item    = 2, /* Item Kind */
        Plant   = 4, /* Flora */
        Passage = 5
    } type;

    uint32 id;
    uint32 unk  <format=hex>;
    float c[9];
    struct 
    {
        float x,y,z;    
    } pos;
    int str_size;
    char str[str_size];
    uint32 entry_no;
    uint32 menu_item_no;
    float scale[3];
} spr[head.spr_count] <optimize=false,read=sceneprop__Read>;

uint32 tag;
uint32 id;
float ss[id*3];


uint32 ido;
uint32 tt[ido * 5];            

uint32 ide;
uint32 yy[ide * 5];     

uint32 idu;



string UIntToStr()
{}

string sceneprop__Read(struct spr_t &m)
{
    string s_entry; SPrintf(s_entry, "%d\n", m.entry_no);
    string s_passa; SPrintf(s_passa, "%d\n", m.menu_item_no);
    if (m.type == Prop || m.type == Item || m.type == Plant)
        return EnumToString(m.type) + " -- " + m.str;
    else if (m.type == Entry)
        return EnumToString(m.type) + " point number " + s_entry;
    else
        return EnumToString(m.type) + " for menu item " + s_passa;
};