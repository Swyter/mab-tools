//------------------------------------------------
//--- 010 Editor v10.0 Binary Template
//
//      File: Mount&Blade Binary Resource File
//   Authors: Swyter
//    E-mail: swyterzone+mab@gmail.com
//   Version: 2020.07.01
//   Purpose: Opens M&B 1.011 and Warband BRF files (Resource/*.brf)
//  Category: Game
// File Mask: *.brf
//
//     Notes: The Warband format changes a bit the original mesh chunk structure; adding
//            tangents for better (tangent-space) normal mapping and other stuff.
//
//            To distinguish between older and newer files, TaleWorlds added a
//            'resource file versioning' chunk, that needs to go first.
//
//            Keep in mind that TaleWorlds used .trf files internally, which are
//            just readable text versions of this very same format, they were generated by
//            their own wonky Blender script exporter that no one outside the company ever used,
//            because they released it very late in the Warband lifecycle, next to the Data part of the
//            module system and the HLSL shaders in text form, when the community had way better tools.
//
//            In the end, I think we all (even them and the modders-turned-authors of the DLCs themselves)
//            ended up using community-provided tools like (first) BRF Edit and then OpenBRF to open and
//            edit these binary counterparts. But originally they weren't meant for authoring, only
//            for faster parsing/loading. Weird how that turned out. Thanks, Marco Tarini! :)
//
//            The game actually spits a `thing.brf` when you put a `thing.trf` in CommonRes or Resources
//            and there isn't already a 'cached' BRF in there. Does it check if the file is newer? ¯\_(ツ)_/¯
//------------------------------------------------

LittleEndian();

typedef struct
{
    uint tag_len;
    char s[tag_len];
} rgltag <read=read_rgltag>;

string read_rgltag(struct rgltag& _thing)
{
    return _thing.s;
}

/* -- */

local uint is_wb_brf = false;

/* swy: the rfver chunk is Warband-only, and what we use to distinguish these files
        from their (mostly identical) 1.011 counterparts */
struct rfver
{
    enum <uint32>
    {
        Warband = 1,        /* swy: there's no version *zero*, Warband introduced the rfver tag at 1, */
    } res_file_version_tag; /*      and Bannerlord uses different formats altogether.                 */

    if (res_file_version_tag == Warband)
        is_wb_brf = true;
};

struct texture /* swy: this is actually more like a texture *reference*, as glue between a material and a .DDS file */
{
    uint object_count;

    struct tex_t
    {
        rgltag tex_name <bgcolor=cSilver>; /* swy: path to the Modules/<mod-name>/Textures/<texture-name>.dds file where the data is actually stored, */
        uint32 flag <format=hex>;          /*      only a limited subset of DX9 DDS textures are supported: ST3C and a few others, not DirectX 11 ones */
    } elem[object_count] <optimize=false, read=read_tex>; /* swy: when a texture has multiple frames (like waterbump) every frame is stored as its own files, like this: <texture-name>_<frame-number-that-starts-at-zero>.dds */
};

struct shader
{
    uint object_count;

    struct sha_t
    {
        rgltag tex_name <bgcolor=cSilver>;
        uint32 flag <format=hex>;
        uint unk_zero;
        rgltag technique; /* swy: originally the HLSL technique name in mb.fx, later also mapped to GLShaders/techniques.xml for GLSL program binding on the OpenGL backend used for Linux, macOS and Android */
        uint alt_count;   /* swy: alt shader names; used as fallback and originally shipped as *.pp asm files for low-spec computers, generally zero or one */
        rgltag alt[alt_count];
        uint count;
        struct
        {
            int map; uint color_op, alpha_op, flag;
        }entry[count];
    } elem[object_count] <optimize=false, read=read_sha>;
};

struct material
{
    uint object_count;

    struct mat_t
    {
        rgltag mat_name <bgcolor=cSilver>;
        uint32 flag <format=hex>;

        rgltag shader_name <bgcolor=cSilver>;

        rgltag diffuse_a <bgcolor=cSilver>;
        rgltag diffuse_b;
        rgltag bump;
        rgltag environ;
        rgltag specular;
        float coeff;
        float spec_r, spec_g, spec_b;
    } elem[object_count] <optimize=false, read=read_mat>;
};

struct mesh
{
    uint object_count;
    struct mesh_t
    {
        rgltag mesh_name <bgcolor=cRed>;
        uint32 flag <format=hex>;
        rgltag mat_name <bgcolor=cSilver>;
        uint pos_cnt;
        struct 
        {
            float x, y, z;
        } pos[pos_cnt];

        uint bone_count;
        if (bone_count) /* swy: todo; FIXME */
        {
            struct bone_influence
            {
                uint bone_id, count;
                struct
                {
                    uint idx;
                    float weight; /* swy: amount of normalized influence this bone has over the vertice */
                } bone[count];
            } bi[bone_count] <optimize=false>;
        }

        uint extra_frames;
        if (extra_frames) /* swy: todo; FIXME */
        {
                
            struct vertex_frame
            {
                uint time;
                uint pos_cnt;
                struct 
                {
                    float x, y, z;
                } pos_[pos_cnt];
                uint nrm_cnt;
                struct 
                {
                    float x, y, z;
                } nrm_[nrm_cnt];
            } v[extra_frames] <optimize=true>;
        }
        uint vtx_cnt;
        struct
        {
            int pos_idx;
            union
            {
              uint color <format=hex>;
              struct
              {
                ubyte r,g,b,a;
              } components;
            } rgb;

            if (!is_wb_brf)
            {
                float  n_a, n_b, n_c, u, v, u_unused, v_unused;  /* swy: OpenBRF copies the u/v fields into the unused ones, which are blank in original BRF files */
            }
            else
            {
                float n_a, n_b, n_c, x_a, x_b, z; byte tangent_flip_or_not_maybe /* handedness?; false => 1 or true => -1 */; float u, v;
            }
        } vtx[vtx_cnt] <optimize=true>;

        int tri_cnt;

        struct
        {
            int a[3];
        } tri[tri_cnt];
    } elem[object_count] <optimize=false, read=read_mesh>;
};

struct skel
{
    uint object_count;
    struct skl_t
    {
        rgltag mesh_name <bgcolor=cRed>;
        uint32 bone_count; /* swy: humans have 20 bones, while mounts have 28 */
        struct
        {
            int parent_idx;
            rgltag bone_name <bgcolor=cSilver>;
            int flag_zero; /* swy: seems unused, I think :) */
            float local_transform_matrix[9]; /* swy: affine transformation 3x3 matrix */
            float x, z, y;
        } bon[bone_count] <optimize=false>;
    } elem[object_count] <optimize=false, read=read_skl>;
};

struct skel_ani
{
    uint object_count;
    struct ska_t
    {
        rgltag mesh_name <bgcolor=cRed>;
        uint32 bone_count; /* swy: humans have 20 bones, while mounts have 28 */
        struct /* swy: bind/T pose bones, in local space; every bone has a parent bone, */
        {      /*      except the root, whose parent is (-1). transform relatively and translate. */
            uint32 frames;
            struct
            {
                uint idx;
                float quaternion[4];
            } a[frames];
        } bon[bone_count] <optimize=false>;

        struct
        {
            uint32 frames;
            struct
            {
                uint frame;
                float pos[3]; /* swy: FIXME: this seems like a relative movement for each frame from the root bone, probably added to the agent position/coordinates in-engine */
            } b[frames];
        } root_bone_translation;
    } elem[object_count] <optimize=false, read=read_ska>;
};

struct body
{
    uint object_count;
    struct body_t
    {
        rgltag body_name;

        struct body_type
        {
            rgltag body_type <bgcolor=cSilver>;

                 if (Stricmp(body_type.s, "composite") == 0)
            {
                uint composite_cnt; /* swy: recursive thingie; contains a number of other sphere/capsule/manifold items */
                struct body_type composite[composite_cnt] <optimize=false>;
            }
            else if (Stricmp(body_type.s, "sphere"   ) == 0)
            {
                float radius, x,z,y; uint flag <format=hex>;
            }
            else if (Stricmp(body_type.s, "capsule"  ) == 0)
            {
                float radius, x,z,y, x,z,y; uint flag <format=hex>;
            }
            else if (Stricmp(body_type.s, "face"     ) == 0) /* swy: only ever used in bo_mesh_passage, as far as I know */
            {
                uint vtx_count; struct { float x, z, y; } vtx[vtx_count]; uint flag <format=hex>;
            }
            else if (Stricmp(body_type.s, "manifold" ) == 0) /* swy: admits quad and triangle soups (maybe even arbitrary polygons?) */
            {
                uint vtx_count;
                struct { float x, z, y; } vtx[vtx_count];

                uint poly_elem;
                struct { int minus_one, unk_zero, vtx_count; uint vtx_idx[vtx_count]; } poly[poly_elem] <optimize=false>;
            }
        } body <optimize=false>;
    } elem[object_count] <optimize=false, read=read_body>;
};


/* swy: iterate over all the posible BRF chunks */
while (FTell() < FileSize())
{
    struct brf_section
    {
        rgltag tag <bgcolor=cDkYellow>;
        /* swy: listed in the same order as in the original code that parses/builds these things from .trf (text) files */
             if (Stricmp(tag.s, "rfver "       ) == 0) struct rfver    ver <open=true, bgcolor=cWhite>; /* swy: versioning chunk prefixing pseudo-header introduced in Warband */
        else if (Stricmp(tag.s, "texture"      ) == 0) struct texture  tex <open=true, bgcolor=cWhite>;
        else if (Stricmp(tag.s, "shader"       ) == 0) struct shader   sha <open=true, bgcolor=cWhite>;
        else if (Stricmp(tag.s, "material"     ) == 0) struct material mat <open=true, bgcolor=cDkGreen>;
        else if (Stricmp(tag.s, "mesh"         ) == 0) struct mesh     mes <open=true, bgcolor=cDkRed>;
        else if (Stricmp(tag.s, "body"         ) == 0) struct body     bod <open=true, bgcolor=cDkBlue>;
        else if (Stricmp(tag.s, "skeleton"     ) == 0) struct skel     skl <open=true, bgcolor=cDkRed>;
        else if (Stricmp(tag.s, "skeleton_anim") == 0) struct skel_ani ska <open=true, bgcolor=cDkRed>;
        else if (Stricmp(tag.s, "end"          ) == 0);
    } section <optimize=false, open=true, read=read_brf>;
}


string UIntToStr(unsigned int e)
{
    string s; SPrintf(s, "%d", e); return s;
}

string read_ver(struct ver_t& _thing)
{
    return "- " + _thing.tex_name.s;
}
string read_tex(struct tex_t& _thing)
{
    return "- " + _thing.tex_name.s;
}
string read_sha(struct sha_t& _thing)
{
    return "- " + _thing.tex_name.s;
}
string read_mat(struct mat_t& _thing)
{
    return "- " + _thing.mat_name.s;
}
string read_mesh(struct mesh_t& _thing)
{
    string s =  "";
    
    SPrintf(s, "* %-80s", _thing.mesh_name.s);

    if (_thing.extra_frames > 0)
        SPrintf(s, "%s (%d vertex frames)", s, _thing.extra_frames + 1);

    if (_thing.bone_count > 0)
        SPrintf(s, "%s      (skinned to %u bones)", s, _thing.bone_count); 

    return s;
}
wstring read_body(struct body_t& _thing)
{
    return "- " + _thing.body_name.s;
}
string read_skl(struct skl_t& _thing)
{
    return "* " + _thing.mesh_name.s;
}
string read_ska(struct ska_t& _thing)
{
    return "* " + _thing.mesh_name.s;
}
string read_brf(struct brf_section& _thing)
{
    return "[" + _thing.tag.s + "]";
}